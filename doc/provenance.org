#+TITLE: Provenance Documentation
#+AUTHOR: Petros Papapanagiotou
#+EMAIL: petrospapapan@gmail.com
#+OPTIONS: toc:2
#+EXCLUDE_TAGS: noexport


* Example

We begin with a motivating example to explain the purpose that provenance fulfils for the visualization of resource-based composition.

** Specification

Assume the following process specifications:
- ~P1~: ~⊢ NEG X, A ⊗ B~
- ~P2~: ~⊢ NEG B, C ⊕ D~
- ~Q1~: ~⊢ NEG A, E~
- ~Q2~: ~⊢ NEG E, NEG (C ⊕ D), Y~

We then perform ~JOIN~ operations for each pair, obtaining the following intermediate compositions:
+ ~P~: ~⊢ NEG X, A ⊗ (C ⊕ D)~
+ ~Q~: ~⊢ NEG A, NEG (C ⊕ D), Y~

Finally, we ~JOIN~ the 2 results to obtain the final composition:
- ~R~: ~⊢ NEG X, Y~

** Visualization

At the logical level, the composition above seems straightforward. The visualization, however, needs to reveal more information. We need to accurately depict how the individual components are connected to each other, and how resources flow between them.

The image below shows the following processes in this order: ~P1~, ~P2~, ~P~, ~Q~, and ~R~.
[[./images/ProvenanceExample.png]]


In the visualization of ~R~, the system has inferred that resource ~A~ connects ~P1~ to ~Q1~, whereas ~P2~ and ~Q2~ are connected by ~C ⊕ D~. This is achieved despite the fact that the last composition action joined intermediate processes ~P~ and ~Q~, meaning the whole term ~A ⊗ (C ⊕ D)~ was "cut" in one go.

This is accomplished by tracking the *input* and *output* provenance of the involved processes. Specifically, when composing ~P~, we track its output provenance for the output ~A ⊗ (C ⊕ D)~ is one where ~A~ came from ~P1~ and ~(C ⊕ D)~ came from ~P2~. Similarly, when composing ~Q~, we track the input provenance, i.e. that ~NEG A~ belongs to ~Q1~ and ~NEG (C ⊕ D)~ belongs to ~Q2~. This way, when ~P~ and ~Q~ are joined, we know exactly where each connected resource is coming from and going to.

* Provenance Trees

We want to be able to track provenance of specific CLL resources. This means subterms of the same term can have different provenance. For this reason, we track provenance using a binary tree structure that matches the syntax tree of the term. The leaves of the tree contain provenance values instead of CLL propositions.

Here is the syntax and provenance trees for the output of ~P~ from the example:
#+BEGIN_EXAMPLE
⊗         ⊗
|\        |\
| \       | \
A  ⊕      P1 ⊕
   |\        |\
   | \       | \
   C  D      P2 P2
#+END_EXAMPLE

If all the propositions in a (sub)tree have the same provenance, we can collapse the provenance (sub)tree to a single node:

#+BEGIN_EXAMPLE
⊗         ⊗
|\        |\
| \       | \
A  ⊕      P1 P2
   |\        
   | \      
   C  D   
#+END_EXAMPLE

* Output Provenance

Each process may only have a single, possibly composite output. When composing processes, the output of the composition often consists of parts of the outputs of its components.

In our example above, ~P~ has output ~A ⊗ (C ⊕ D)~ consisting of ~A~ coming from ~P1~ and ~C ⊕ D~ coming from ~P2~. This is exactly what the provenance tree represents.

The output provenance tree of each process is stored in its structure and used during composition. It is also copied as an output provenance entry, which maps each process name to its output provenance, in the composition state. This allows the composition tactics to gain access to that information.

Apart from names of component atomic (or collapsed composite) processes who own part of the output, the leaves of an output provenance tree may have special values as described next.

** The ~&~ prefix

Provenance leaves starting with a ~&~ prefix indicate a "merge node" as the source of the output.

When using ~WITH~ and in some cases of optional outputs in ~JOIN~ we need to introduce a "merge node" to indicate that 2 (or more) outputs are merged into a single (usually optional) output. This is one way of showing how the options come together, without showing disconnected outputs from different processes. 

Outputs coming out of such a merge node can no longer be linked back to the components they came from without breaking the correlation between the options. 

In other cases, two equivalent options are merged into a single output as an "optimization" step to avoid redundant case splits. A merge node is also used here, and the merged output has an unclear (double?) provenance.

In such cases we mark the provenance of the new output using ~&~ followed by the name of the composition that introduced the merge node.

** Unused inputs and the ~:~ tag

When dealing with optional outputs, the ~JOIN~ action often needs to build buffers for unused inputs. See the standard example below:
[[./images/StandardOptionalJoin.png]]

What should the output provenance for ~B~ be? Here it clearly should be ~Q~. However, ~Q~ may not be atomic, but an intermediate composition instead. The reasoner does not know whether ~Q~ is composed of multiple components and which component ~B~ is coming from.

Mirroring the image above, here are 2 examples where ~Q~ is a composite process consisting of ~Q1~ and ~Q2~ (top) and ~Q3~ and ~Q4~ (bottom):
[[./images/UnusedInputProvenance.png]]

In the top case, ~B~ is an input of ~Q2~, whereas in the bottom case ~B~ is an input of ~Q3~. In both cases, the reasoner just sees an intermediate composition ~Q~ with inputs ~B~ and ~E~ and output ~Y~ as in the previous image. We therefore need a different way of tagging the provenance of ~B~ in a way that allows us to trace it back to ~Q2~ or ~Q3~.

This is accomplished by reporting the channel ~c~ of the unused input ~B~. In the example above, the reasoner will produce a provenance leaf ~Q:c~, i.e. the name of the (possibly composite) process ~Q~ followed by a colon ~:~ followed by the name of the channel of the unused input ~c~.

The reasoner is effectively telling the graph interface to search in the process ~Q~ for an input with channel ~c~ and use the owner of that input as the source of ~B~.

This may cause issues when multiple identical components introduce the same channel name multiple times in the same composition. The reasoner does not currently diambiguate between those because it does not even have that information.

* Input Provenance

Each process can have multiple inputs, each with its own unique channel. This means we can generally track the owner of an input through the channel. 

In our example above, ~NEG (C ⊕ D)~ of ~Q2~ will have a unique channel name, let's assume ~cQ~. When composing ~Q1~ with ~Q2~, this input is not affected. This means if we try to connect something to it, we already know ~cQ~ belongs to ~Q2~ so we can track its provenance and connect the graph appropriately.

The composition actions only affect input channels in 2 ways:
1. The ~WITH~ action constructs new inputs that are options or merges of other inputs. These are reported in the composition step and their provenance is linked to the composite process, not its components.
2. The ~JOIN~ action manipulates inputs in order to match the output of the other (left) component. This includes adding buffers, using inputs from different components and merging options. In this case, we need to track the provenance of each part in the constructed input.

Back to our example, when composing ~P~ with ~Q~, we connect ~NEG A~ with ~NEG (C ⊕ D)~ to create a new input ~NEG (A ⊗ (C ⊕ D))~ that matches the output of ~P~. At that point, we need to track that ~NEG A~ had some channel ~cP~ which can be traced back to ~P~, whereas ~NEG (C ⊕ D)~ had channel ~cQ~ that we know belongs to ~Q~. For this reason, we build the following provenance tree (shown next to the input parse tree), while ignoring the negation:
#+BEGIN_EXAMPLE
⊗         ⊗
|\        |\
| \       | \
A  ⊕      cP ⊕
   |\        |\
   | \       | \
   C  D     cQ cQ
#+END_EXAMPLE

Note that the leaves of an input provenance tree, in principle, contain channels as opposed to those of an output provenance tree which contain process names. 

There are a few particularities and special cases of leaves for input provenance, which we describe next.

** Disambiguating same channels

** The ~#~ provenance 

** The ~&~ prefix
