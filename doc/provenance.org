#+TITLE: Provenance Documentation
#+AUTHOR: Petros Papapanagiotou
#+EMAIL: petrospapapan@gmail.com
#+OPTIONS: toc:2
#+EXCLUDE_TAGS: noexport


* Example

We begin with a motivating example to explain the purpose that provenance fulfils for the visualization of resource-based composition.

** Specification

Assume the following process specifications:
- ~P1~: ~⊢ NEG X, A ⊗ B~
- ~P2~: ~⊢ NEG B, C ⊕ D~
- ~Q1~: ~⊢ NEG A, E~
- ~Q2~: ~⊢ NEG (C ⊕ D), Y~

We then perform ~JOIN~ operations for each pair, obtaining the following intermediate compositions:
- ~P~: ~⊢ NEG X, A ⊗ (C ⊕ D)~
- ~Q~: ~⊢ NEG A, NEG (C ⊕ D), Y~

Finally, we ~JOIN~ the 2 results to obtain the final composition:
- ~R~: ~⊢ NEG X, Y~

** Visualization

At the logical level, the composition above seems straightforward. The visualization, however, needs to reveal more information. We need to accurately depict how the individual components are connected to each other, and how resources flow between them.

The image below shows the following processes in this order: ~P1~, ~P2~, ~P~, ~Q~, and ~R~.
[[./images/ProvenanceExample.png]]


In the visualization of ~R~, the system has inferred that resource ~A~ connects ~P1~ to ~Q1~, whereas ~P2~ and ~Q2~ are connected by ~C ⊕ D~. This is achieved despite the fact that the last composition action joined intermediate processes ~P~ and ~Q~, meaning the whole term ~A ⊗ (C ⊕ D)~ was "cut" in one go.

This is accomplished by tracking the *input* and *output* provenance of the involved processes. Specifically, when composing ~P~, we track its output provenance for the output ~A ⊗ (C ⊕ D)~ is one where ~A~ came from ~P1~ and ~(C ⊕ D)~ came from ~P2~. Similarly, when composing ~Q~, we track the input provenance, i.e. that ~NEG A~ belongs to ~Q1~ and ~NEG (C ⊕ D)~ belongs to ~Q2~. This way, when ~P~ and ~Q~ are joined, we know exactly where each connected resource is coming from and going to.

* Provenance Trees

We want to be able to track provenance of specific CLL resources. This means subterms of the same term can have different provenance. For this reason, we track provenance using a binary tree structure that matches the syntax tree of the term. The leaves of the tree contain provenance values instead of CLL propositions.

Here is the syntax and provenance trees for the output of ~P~ from the example:
#+BEGIN_EXAMPLE
⊗         ⊗
|\        |\
| \       | \
A  ⊕      P1 ⊕
   |\        |\
   | \       | \
   C  D      P2 P2
#+END_EXAMPLE

If all the propositions in a (sub)tree have the same provenance, we can collapse the provenance (sub)tree to a single node:

#+BEGIN_EXAMPLE
⊗         ⊗
|\        |\
| \       | \
A  ⊕      P1 P2
   |\        
   | \      
   C  D   
#+END_EXAMPLE

* Output Provenance

Each process may only have a single, possibly composite output. When composing processes, the output of the composition often consists of parts of the outputs of its components.

In our example above, ~P~ has output ~A ⊗ (C ⊕ D)~ consisting of ~A~ coming from ~P1~ and ~C ⊕ D~ coming from ~P2~. This is exactly what the provenance tree represents.

The output provenance tree of each process is stored in its structure and used during composition. It is also copied as an output provenance entry, which maps each process name to its output provenance, in the composition state. This allows the composition tactics to gain access to that information.

Apart from names of component processes who own part of the output, the leaves of an output provenance tree may have special values as described next.

** The ~&~ prefix

Provenance leaves starting with a ~&~ prefix indicate a "merge node" as the source of the output.

When using ~WITH~ and in some cases of optional outputs in ~JOIN~ we need to introduce a "merge node" to indicate that 2 (or more) outputs are merged into a single (usually optional) output. This is one way of showing how the options come together, without showing disconnected outputs from different processes. 

Outputs coming out of such a merge node can no longer be linked back to the components they came from without breaking the correlation between the options. 

In other cases, two equivalent options are merged into a single output as an "optimization" step to avoid redundant case splits. A merge node is also used here, and the merged output has an unclear (double?) provenance.

In such cases we mark the provenance of the new output using ~&~ followed by the name of the composition that introduced the merge node.

* Input Provenance

Each process can have multiple inputs, each with its own unique channel. This means we can generally track the owner of an input through the channel. 

The composition actions only affect input channels in 2 ways:
1. The ~WITH~ action constructs new inputs that are options or merges of other inputs. These are reported in the composition step and their provenance is linked to the composite process, not its components.
2. The ~JOIN~ action manipulates inputs in order to match the output of the other (left) component. This includes adding buffers, using inputs from different components and merging options. In this case, we need to track the provenance of each part in the constructed input.

The different types of input provenance are described next.

** The ~#~ Provenance
