[{"body":"The WorkflowFM Reasoner is implemented within the interactive theorem proving environment of HOL Light.\nIt also depends on 3 additional libraries that need to be present in the HOL Light directory.\nWe have a repository set up for a quick configuration, or you can install everything manually.\n","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/install/","title":"Installation"},{"body":"Quick setup Clone the following repository: https://github.com/workflowfm/hol-light\n1git clone https://github.com/workflowfm/hol-light.git Then make sure all the submodules are initialised and updated:\n1git submodule update --init --recursive Manual setup Assuming an existing installation of HOL Light, you can setup the reasoner manually by installing the following libraries:\n The Isabelle Light library. This also comes bundled with HOL Light by default. Additional HOL Light tools. This consists of useful snippets of code, libraries, and theorems. This should be installed in a tools/ directory within HOL Light. The HOL Light embed library which enables reasoning with encoded logics. This should be installed in a embed/ directory within HOL Light.  It is important to use the correct directory names, as the reasoner will seek to load specific files from each library.\r\rFinally, install the reasoner itself by cloning the repository to a workflowfm/ directory within HOL Light:\n1git clone https://github.com/workflowfm/workflowfm-reasoner.git worklfowfm ","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/install/setup/","title":"Setup"},{"body":"You can install HOL Light by following its standard installation instructions.\nWe have included our own notes below in case they are helpful.\nSpecific tips for DICE users at the University of Edinburgh are included below.\r\rInstall OCaml OCaml 4.07.0 minimum is required. The easiest way to install this is through opam.\nOn DICE, opam can be compiled from source and installed locally. It is better to use a locally installed OCaml than the centrally available one.\r\rYou also need to install the `num` and `camlp5` packages:\n1opam install num camlp5 In many cases (including on DICE) the toplevel loads camlp4. In order to load camlp5 by default, you need to edit the .ocamlinit file in your home directory (opam usually creates one, otherwise add it yourself). Add the following to that file:\n1#use \u0026#34;topfind\u0026#34;;; 2#require \u0026#34;camlp5\u0026#34;;; 3#load \u0026#34;camlp5o.cma\u0026#34;;; Running ocaml should give you a Camlp5 parsing version ... at the end.\nRun HOL Light To install/run HOL Light, first create the pa_j.ml file:\n1make The run ocaml and load HOL Light:\n1#use \u0026#34;hol.ml\u0026#34;;; Checkpointing Checkpointing eliminates loading times, which are otherwise relatively long, especially when you need to restart HOL Light during development.\nWe have been using DMTCP. Unfortunately, newer versions seem to be failing with HOL Light in a number of different platforms, but it is still worth trying.\nVersion 2.0.0 and above does not seem to work on DICE. Try version 1.2.4.\r\rOnce you have installed DMTCP, you can create the checkpoint as follows:\n1dmtcp_checkpoint ocaml Then load HOL Light as usual:\n1#use \u0026#34;hol.ml\u0026#34;;; Wait for it to finish, then open a new terminal and checkpoint:\n1dmtcp_command -c There is no notification when the checkpoint is complete other than the appearance of the dmtcp_restart_script.sh shortcut. You can then kill/exit OCaml.\nRunning dmtcp_restart_script.sh should load the checkpoint from where you left it. Issue a command to HOL Light/OCaml to make sure it works.\nSubsequent uses of dmtcp_command -c will update your checkpoint.\n","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/install/hol-light/","title":"Install HOL Light"},{"body":"Once you have HOL Light up and running, you can load the reasoner in console mode using the following command:\n1loads (!hol_dir ^ \u0026#34;/workflowfm/make.console.ml\u0026#34;);; If you need to use the JSON mode, you can use this command instead:\n1loads (!hol_dir ^ \u0026#34;/workflowfm/make.ml\u0026#34;);; ","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/install/load/","title":"Loading the reasoner"},{"body":"The second mode of the WorkflowFM Reasoner exposes a JSON API that can enable interaction with external and web based systems.\nThe JSON API mode can be loaded using the following command:\n1loads (!hol_dir ^ \u0026#34;/workflowfm/make.ml\u0026#34;);; The rest of this section describes the main types involved in the JSON schema, as well as the format for providing commands and the responses the reasoner can generate.\n","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/json/","title":"JSON API"},{"body":"Linear Propositions linprop\nDescription:\nLinear terms are either:\n atoms subterms connected by tensor or plus negations of terms  Structure:\n type: string = \u0026quot;var\u0026quot; | \u0026quot;neg\u0026quot; | \u0026quot;times\u0026quot; | \u0026quot;plus\u0026quot; name: string = the name of the atom if type = \u0026quot;var\u0026quot;, otherwise ignored args: array of linprop = the list of arguments if type is neg, times or plus, otherwise ignored. Binary operators times and plus can have more than 2 arguments, in which case they are applied in a right associative way  Annotated terms linterm\nDescription:\nAnnotated terms are linear propositional terms annotated with a channel.\nStructure:\n cll: linprop channel: string  Composition actions action\nDescription:\nComposition actions describe a binary combination of 2 labelled processes.\nStructure:\n act: string = the type of composition, currently \u0026quot;JOIN\u0026quot; | \u0026quot;TENSOR\u0026quot; | \u0026quot;WITH\u0026quot; for sequential, parallel, and conditional composition respectively larg: string = the name of the first (or \u0026quot;left\u0026quot;) component process lsel: string = a string describing some relevant part of the left process component. This is different depending on the action type. rarg: string = the name of the second (or \u0026quot;right\u0026quot;) component process rsel: string = a string describing some relevant part of the right process component. This is different depending on the action type. res: string = the desired label for the resulting composition  [TODO] Selections are expected as follows:\n TENSOR: WITH: JOIN:  Provenance prov\nDescription:\nProvenance trees are used to determine the origin of each linear proposition in an input or output term.\nFor example, consider 2 processes:\n P with input X and output A ** B Q with inputs B and Y and output C  These can be joined through B. The resulting composition will have inputs X and Y and output A ** C. In this the following hold:\n X has an input provenance of P Y has an input provenance of Q In the output, A comes from P and C comes from Q so we construct the JSON object \u0026quot;P ** Q\u0026quot;  The structure of the provenace tree matches the syntax tree of the corresponding term. For this reason with copy the structure of linprop but use the name to record the provenance label instead of the atom name.\nSubtrees where all propositions have the same provenance can be replaced by an atomic/leaf provenance node with the single label. This is the only exception of the provenance tree not matching the syntax tree.\nStructure:\n type: string = \u0026quot;source\u0026quot; | \u0026quot;times\u0026quot; | \u0026quot;plus\u0026quot; name: string = the provenance label if type = \u0026quot;source\u0026quot;, otherwise ignored args: array of prov = the list of arguments if type is times or plus, otherwise ignored. Binary operators times and plus can have more than 2 arguments, in which case they are applied in a right associative way  [TODO: clarify provenance labels]\nProvenance entries prov_entry and iprov_entry\nDescription:\nProvenance info is kept in the state. Provenance entries associate a provenance tree to the output (prov_entry) or input (iprov_entry) it corresponds to. Output provenance is associated with a process label whose output it describes. Input provenance is associated with an available input term.\n[TODO: clarify]\n*In the future, provenance info will be kept directly in the process instead of the state.- This will make thing a bit more intuitive.\nStructure: prov_entry:\n name: string = the name/label of the process whose output we are describing prov: prov = the corresponding provenance tree  iprov_entry:\n term: linprop = the (non-negated) linear term of the input we are describing prov: prov = the corresponding provenance tree  Action state actionstate\nDescription:\nThe action state is used to convey state info to the prover and retrieve proof metadata afterwards.\nStructure:\n label: string = a unique label identifying the composite process under contruction ctr: int = a non-negative counter used to keep variables fresh. Expected to be initialized to 0. buffered: array of linprop = the types of buffers that were constructed during proof. This used to be the way to determine buffered edges in the frontend, but is now obsolete thanks to the provenance trees. joined: array of linterm = the inputs that were used up/connected during a JOIN action. iprov: array of iprov_entry = input povenance entries prov: array of prov_entry = output provenance entries  Agent agent\nAn agent refers to a pi-calculus agent corresponding to a process specification. Currently this is just a string, but we have plans to adopt a more structured representation in the near future.\nProcess process\nDescription:\nThe complete specification of a process.\nStructure:\n name: string = a name/label for the process inputs: array of linterm output: linterm prov: prov = the output provenance proc: agent = the pi-calculus specification actions: array of action = a list of composition actions that construct this process. Empty if the process is atomic. copier: bool = true if the prover determines this to be a copy node intermediate: bool = true if this is an intermediate composition step (as opposed to an atomic process or completed composition)  ","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/json/types/","title":"Main Types"},{"body":"JSON commands can be issued to the WorkflowFM Reasoner using the following function:\n1Json_composer_io.execute \u0026#34;JSON\u0026#34;;; Replace JSON with one of the commands described below, in JSON format.\nYou can also execute a JSON command stored in a file as follows:\n1Json_composer_io.execute_file \u0026#34;path/to/file.json\u0026#34;;; \rAll commands include a command field of type string which defines the type of the command.\r\rPing Description:\nPing/keep-alive command. Gives a Pong response.\nStructure:\n command: string = \u0026quot;ping\u0026quot; ping: float = a timestamp to measure ping  Create Description:\nA command to create a new atomic process.\nStructure:\n command: string = \u0026quot;create\u0026quot; name: string = the name of the process to be created inputs: array of linprop = a list of inputs. Their channels will be created by the prover. output: linprop = the process output. The channcel will be created by the prover.  Binary compose (compose1) Description:\nBinary composition of 2 processes with a single action.\nAlthough a more general composition command is provided, when it comes to simple binary compositions this command executes faster.\nStructure:\n command: string = \u0026quot;compose1\u0026quot; action: action = the composition action to be performed. The labels of the 2 arguments must match the labels of the processes provided in the next fields. lhs: process = the process corresponding to the first (left) argument of the action rhs: process = the process corresponding to the second (right) argument of the action  Compose Description:\nConstruction of a complex composition with one or more actions. Although more general than the binary composition command compose1, it is slower.\nStructure:\n command: string = \u0026quot;compose\u0026quot; name: string = the name of the final composition components: array of process = the list of all component processes that will be used actions: array of action = the ordered list of actions to be performed  Verify Description:\nA command used to reconstruct a process composition.\nThis is legacy command which has now devolved into the compose command. The only difference is that verify does not produce compose responses for intermediate steps. It will only generate one verify response for the final process.\nStructure:\n command: string = \u0026quot;verify\u0026quot; name: string = the name of the final composition components: array of process = the list of all component processes that will be used actions: array of action = the ordered list of actions to be performed  Deploy Description:\nThis is a family of commands that produce executable process deployments.\nThere are currently 3 types of possible deployments:\n PiViz: This produces a file for the PiVizTool and/or MWB. PiLib: This produces a deployment and code templates using the old PiLib library. PEW: This produces a deployment and code templates with the newer PEW library.  Structure:\nPiViz  command: string = \u0026quot;piviz\u0026quot; process: process = the process to be deployed components: array of process = the list of all dependencies/components required in the composition  PiLib  command: string = \u0026quot;pilib\u0026quot; process: process = the process to be deployed components: array of process = the list of all dependencies/components required in the composition separator: string = the client OS-specific file path separator path: string = the base path for the deployment pkg: string = the desired name for the Scala package that will contain the code project: string = an identifiable name for the deployment. This will be used to identify certain types and classes. main: bool = true if the generation of a template for a main class is required. java: bool = true if the generation of a java runner class is required. This can help integrate the Scala deployment with Java code.  PEW  command: string = \u0026quot;piviz\u0026quot; process: process = the process to be deployed components: array of process = the list of all dependencies/components required in the composition separator: string = the client OS-specific file path separator path: string = the base path for the deployment pkg: string = the desired name for the Scala package that will contain the code project: string = an identifiable name for the deployment. This will be used to identify certain types and classes. main: bool = true if the generation of a template for a main class is required. java: bool = true if the generation of a java runner class is required. This can help integrate the Scala deployment with Java code.  ","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/json/commands/","title":"Commands"},{"body":"JSON responses are provided in standard output, wrapped between a line containing the string JSON_START and a line containing the string JSON_END. HOL Light will also yield additional output outside those 2 lines.\nYou can therefore parse JSON output using a regular expression of the form \u0026quot;JSON_START(.*?)JSON_END\u0026quot;.\nAll responses include a response field of type string which defines the type of the response.\r\rPong Description:\nThe response to the Ping command.\nStructure:\n response: string = \u0026quot;Pong\u0026quot; ping: float = contains the original timestamp received by the prover in the Ping command.  Create Description:\nThe response to the create command with a definition of a new atomic process.\nStructure:\n response: string = \u0026quot;CreateProcess\u0026quot; process: process = the newly created process  Compose Description:\nThe result of a single binary composition action. The compose command may produce multiple of these, one for each action.\nStructure:\n response: string = \u0026quot;Compose\u0026quot; action: action = the composition action that was applied process: process = the resulting composite process state: actionstate = the updated action state with the associated metadata  Verify Description:\nThe response of the verify command with a reconstructed composite process.\nStructure:\n response: string = \u0026quot;Verify\u0026quot; process: process = the reconstructed composition  Deploy Description:\nThis is the response to the deploy commands. It describes the files that are required for deployment.\nStructure:\nFirst we need the structure for a single deployment file. This is a file object containing the following fields:\n path: string = the full path of the file (including its name) in the deployment content: string = the content of the file overwrite: bool = the reasoner tags the files that are generated fully automatically so that they will be overwritten in consecutive deployments. Files that may be edited by the user (e.g. code templates) have this field marked as false to avoid overwritting user content.  Based on this, the deploy response is as follows:\n response: string = \u0026quot;Deploy\u0026quot; type: string = the type of deployment. Currently one of PiViz, PiLib or PEW. deployment: Array of file = a list of deployment files.  Failed Description:\nThis response is generated whenever the prover fails to perform a command. Unless there is a bug or associated limitation in the prover, this indicates a user or input error.\nStructure:\n response: string = \u0026quot;CommandFailed\u0026quot; content: string = a (sometimes useful) description of the error that occured  Exception Description:\nThis response is generated whenever the prover fails due to an internal exception. This indicates an expected failure in the system.\nStructure:\n response: string = \u0026quot;Exception\u0026quot; content: string = the contents of the thrown exception  ","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/json/responses/","title":"Responses"},{"body":"Provenance\n","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/provenance/","title":"Provenance"},{"body":"We begin with a motivating example to explain the purpose that provenance fulfils for the visualization of resource-based composition.\nSpecification Assume the following process specifications:\n P1: ⊢ NEG X, A ⊗ B P2: ⊢ NEG B, C ⊕ D Q1: ⊢ NEG A, E Q2: ⊢ NEG E, NEG (C ⊕ D), Y  We then perform JOIN operations for each pair, obtaining the following intermediate compositions:\n P: ⊢ NEG X, A ⊗ (C ⊕ D) Q: ⊢ NEG A, NEG (C ⊕ D), Y  Finally, we JOIN the 2 results to obtain the final composition:\n R: ⊢ NEG X, Y  Visualization At the logical level, the composition above seems straightforward. The visualization, however, needs to reveal more information. We need to accurately depict how the individual components are connected to each other, and how resources flow between them.\nThe image below shows the following processes in this order: P1, P2, P, Q, and R.\n\rIn the visualization of R, the system has inferred that resource A connects P1 to Q1, whereas P2 and Q2 are connected by C ⊕ D. This is achieved despite the fact that the last composition action joined intermediate processes P and Q, meaning the whole term A ⊗ (C ⊕ D) was \u0026quot;cut\u0026quot; in one go.\nThis is accomplished by tracking the input and output provenance of the involved processes. Specifically, when composing P, we track its output provenance for the output A ⊗ (C ⊕ D) is one where A came from P1 and (C ⊕ D) came from P2. Similarly, when composing Q, we track the input provenance, i.e. that NEG A belongs to Q1 and NEG (C ⊕ D) belongs to Q2. This way, when P and Q are joined, we know exactly where each connected resource is coming from and going to.\n","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/provenance/example/","title":"Example"},{"body":"Each process may only have a single, possibly composite output. When composing processes, the output of the composition often consists of parts of the outputs of its components.\nIn our example above, P has output A ⊗ (C ⊕ D) consisting of A coming from P1 and C ⊕ D coming from P2. This is exactly what the provenance tree represents.\nThe output provenance tree of each process is stored in its structure and used during composition. It is also copied as an output provenance entry, which maps each process name to its output provenance, in the composition state. This allows the composition tactics to gain access to that information.\nApart from names of component atomic (or collapsed composite) processes who own part of the output, the leaves of an output provenance tree may have special values as described next.\nThe \u0026amp; prefix Provenance leaves starting with a \u0026amp; prefix indicate a \u0026quot;merge node\u0026quot; as the source of the output.\nWhen using WITH and in some cases of optional outputs in JOIN we need to introduce a \u0026quot;merge node\u0026quot; to indicate that 2 (or more) outputs are merged into a single (usually optional) output. This is one way of showing how the options come together, without showing disconnected outputs from different processes.\nOutputs coming out of such a merge node can no longer be linked back to the components they came from without breaking the correlation between the options.\nIn other cases, two equivalent options are merged into a single output as an \u0026quot;optimization\u0026quot; step to avoid redundant case splits. A merge node is also used here, and the merged output has an unclear (double?) provenance.\nPerhaps the simplest example is shown below:\n\rIn this, the second option E of P is converted to the type of the first option A through Q. This fits the intuition of a recovery process that recovers from an exception E to produce an expected A. The result of the composition is a single A output, whether it came from P in the first place or from Q after \u0026quot;recovery\u0026quot;.\nIf A gets connected to another process, whether the source will be P or Q is only determined at runtime. We therefore use the \u0026amp; merge node and label the output provenance to represent that the A output will be coming from this particular merge node.\nIn such cases we mark the provenance of the new output using \u0026amp; followed by the name of the composition that introduced the merge node.\nUnused inputs and the : tag When dealing with optional outputs, the JOIN action often needs to build buffers for unused inputs. See the standard example below:\n\rWhat should the output provenance for B be? Here it clearly should be Q. However, Q may not be atomic, but an intermediate composition instead. The reasoner does not know whether Q is composed of multiple components and which component B is coming from.\nMirroring the image above, here are 2 examples where Q is a composite process consisting of Q1 and Q2 (top) and Q3 and Q4 (bottom):\n\rIn the top case, B is an input of Q2, whereas in the bottom case B is an input of Q3. In both cases, the reasoner just sees an intermediate composition Q with inputs B and E and output Y as in the previous image. We therefore need a different way of tagging the provenance of B in a way that allows us to trace it back to Q2 or Q3.\nThis is accomplished by reporting the channel c of the unused input B. In the example above, the reasoner will produce a provenance leaf Q:c, i.e. the name of the (possibly composite) process Q followed by a colon : followed by the name of the channel of the unused input c.\nThe reasoner is effectively telling the graph interface to search in the process Q for an input with channel c and use the owner of that input as the source of B.\nThis may cause issues when multiple identical components introduce the same channel name multiple times in the same composition. The reasoner does not currently diambiguate between those because it does not even have that information.\n","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/provenance/output/","title":"Output Provenance"},{"body":"We want to be able to track provenance of specific CLL resources. This means subterms of the same term can have different provenance. For this reason, we track provenance using a binary tree structure that matches the syntax tree of the term. The leaves of the tree contain provenance values instead of CLL propositions.\nHere is the syntax and provenance trees for the output of P from the example:\n1⊗ ⊗ 2|\\ |\\ 3| \\ | \\ 4A ⊕ P1 ⊕ 5 |\\ |\\ 6 | \\ | \\ 7 C D P2 P2 If all the propositions in a (sub)tree have the same provenance, we can collapse the provenance (sub)tree to a single node:\n1⊗ ⊗ 2|\\ |\\ 3| \\ | \\ 4A ⊕ P1 P2 5 |\\ 6 | \\ 7 C D ","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/provenance/trees/","title":"Provenance Trees"},{"body":"Each process can have multiple inputs, each with its own unique channel. This means we can generally track the owner of an input through the channel.\nIn our example above, NEG (C ⊕ D) of Q2 will have a unique channel name, let's assume cQ. When composing Q1 with Q2, this input is not affected. This means if we try to connect something to it, we already know cQ belongs to Q2 so we can track its provenance and connect the graph appropriately.\nThe composition actions only affect input channels in 2 ways:\n The WITH action constructs new inputs that are options or merges of other inputs. These are reported in the composition step and their provenance is linked to the composite process, not its components. The JOIN action manipulates inputs in order to match the output of the other (left) component. This includes adding buffers, using inputs from different components and merging options. In this case, we need to track the provenance of each part in the constructed input.  Back to our example, when composing P with Q, we connect NEG A with NEG (C ⊕ D) to create a new input NEG (A ⊗ (C ⊕ D)) that matches the output of P. At that point, we need to track that NEG A had some channel cP which can be traced back to P, whereas NEG (C ⊕ D) had channel cQ that we know belongs to Q. For this reason, we build the following provenance tree (shown next to the input parse tree), while ignoring the negation:\n1⊗ ⊗ 2|\\ |\\ 3| \\ | \\ 4A ⊕ cP ⊕ 5 |\\ |\\ 6 | \\ | \\ 7 C D cQ cQ Note that the leaves of an input provenance tree, in principle, contain channels as opposed to those of an output provenance tree which contain process names.\nThere are a few particularities and special cases of leaves for input provenance, which we describe next.\nDisambiguating same channels with a : tag Assume a process Q with an input A ⊕ B on channel cQ. In the image shown below, we TENSOR Q with itself and then JOIN it with a process P with output (A ⊕ B) ⊗ (A ⊕ B):\n\rAs we are joining P to the the 2 Q processes, the reasoner will apply the par rule to compose the 2 A ⊗ B inputs into one that matches the output of P. Sticking to the explanation of input provenance we provided above, the input provenance for the composite input will be (cQ ⊕ cQ) ⊗ (cQ ⊕ cQ).\nThis would lead the graph engine to look for 4x cQ channels and fail because there are only 2 available, one for each instance of Q. The reasoner needs to somehow convey the information that the first 2 cQ channels in the provenance tree refer to the same channel, whereas the other 2 cQ channels refer to a single other channel.\nThis is accomplished by tagging each channel in the provenance tree with an integer. If 2 leaves in the provenance tree have the same channel and same number, they refer to the same, single channel. If hey have the same channel name, but a different number, they refer to 2 separate instances of that channel. Note that the actual number used has no other significance and is merely linked to an internal proof counter.\nIn our example, the reasoner will report an input provenance (cQ:4 ⊕ cQ:4) ⊗ (cQ:7 ⊕ cQ:7) (or some other numbers instead of 4 and 7). This is how the graph engine that generated the image above knew how to connect one A and one B to the top Q, corresponding to channel cQ:4, and the other A and the other B to the second Q, corresponding to channel cQ:7.\nThe # provenance In some cases, an input being connected does not feed to any (atomic) process, but belongs to a buffer that is introduced. Such an input will be forwarded to the output of the composite process without change.\nThe reasoner reports the input provenance of such buffers using a hash # label for the leaf.\nIn our current composer implementation, we use a triangle \u0026quot;join\u0026quot; (or \u0026quot;terminator\u0026quot;) node as a target to connect buffered resources to.\nThe \u0026amp; prefix The issue of merged options in output provenance needs to be dealt with in input provenance too.\nLet's revisit the same example:\n\rAs we are joining P and Q, the reasoner constructs an optional input A ⊕ E for Q using its existing input E and introducing a buffer of type A. Once the new input is constructed, we need to provide its input provenance. This must be such that E gets connected to Q, whereas A is connected to the merge node.\nThe reported input provenance is \u0026amp;_Step1 ⊕ cQ:5, where _Step1 the name of the composition, cQ the input channel of Q, and 5 some integer.\n","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/provenance/input/","title":"Input Provenance"},{"body":"Further clarifying and simplifying the provenance information is an obvious want for the future.\nA few particularities exist because of the violation of channel uniqueness, so solving this problem in a more general way will help simplify provenance too.\nDepending on further developments and needs of the frontend graph engine, we may extend provenance labels. The fact that the leaves can have any string as a label makes this structure very flexible and expandable.\n","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/provenance/future/","title":"Future Work"},{"body":"Welcome to the WorkflowFM Reasoner documentation.\nGet started ","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/","title":"Reference"},{"body":" \nA logic-based library for correct-by-construction process modelling and composition.\r\rRead the DocsSource\nAbout This is a HOL Light library that allows for rigorous, formally verified process specification and composition. Processes can be specified based on the types of their input and output resources, using Classical Linear Logic (CLL) sequents. Composition can then be achieved using forward chaining/inference of CLL rules.\nInference can be applied directly using the standard HOL Light interactive proof setting and the embed library. Alternatively, the WorkflowFM Reasoner also provides its own interface with intuitive commands that greatly facilitate process specification and composition.\nCLL proofs are annotated with π-calculus process terms based on the proofs-as-processes paradigm. These provide an executable translation of the logical composition. The resulting workflows are correct-by-construction with the following verified properties:\n Systematic resource accounting: The linearity of CLL guarantees that no resources appear out of nowhere or disappear into thin air. Deadlock and livelock freedom: The proofs-as-processes paradigm guarantees that the constructed workflows have no deadlocks or livelocks. Type checked composition: Even though the generated π-calculus term is untyped, the correctness of the types of all connected resources is ensured via the logical proof. Fully asynchronous and concurrent execution: The π-calculus naturally offers a workflow execution style where each component process can be executed fully asynchronously (see the PEW engine for more details) and concurrently, without introducing any conflicts, race conditions, or deadlocks.  The constructed workflows can be exported either for visualization using the PiVizTool or as Scala code for execution using the PEW engine.\nThe references provide more in depth details of the theory behind the WorkflowFM Reasoner.\nKey Features  Process specification using Classical Linear Logic (CLL). Process composition using formally verified forward inference. Interactive theorem proving in CLL. Intuitive high-level actions for sequential, conditional, and parallel composition. Proof translation to π-calculus. Modular encoding allows different CLL translations (e.g. to session types), automatically reconstructing the entire process reasoning framework. Tracking of provenance metadata during proof to guide visualization. Export π-calculus to PiVizTool format. Export Scala code to execute workflows using the PEW engine. Modular API allows extensions with new composition actions, export options and commands.  Modes The reasoner can run in 2 modes:\n Console: This mode is intended for standard use within HOL Light, i.e. at the OCaml toplevel. It provides a minimal console interface for process modelling and composition. JSON: This mode is intended for use within a server environment, to allow interaction with web applications (including UIs). It expects input and produces output encoded in JSON format.  \nAuthors Maintainer Petros Papapanagiotou -  -  - \nContributors A big thank you to the following contributors in order of appearance:\n Jacques Fleuriot -   Groups \u0026amp; Organizations \r\rArtificial Intelligence Modelling Lab\r\r\rArtificial Intelligence and its Applications Institute\r\r\rSchool of Informatics, University of Edinburgh\r\r\r\r\nReferences Please cite the following publication in reference to this project:\n P. Papapanagiotou, J. Fleuriot. WorkflowFM: A Logic-Based Framework for Formal Process Specification and Composition. CADE, 2017.  Sample of other relevant references:\n P. Papapanagiotou, J. Fleuriot. Formal Verification of Web Services Composition Using Linear Logic and the pi-calculus. ECOWS, 2011. P. Papapanagiotou. A formal verification approach to process modelling and composition. PhD Thesis, 2014. P. Papapanagiotou, J. Fleuriot. A Pragmatic, Scalable Approach to Correct-by-construction Process Composition Using Classical Linear Logic Inference. LOPSTR, 2019.  License Distributed under the Apache 2.0 license. See LICENSE for more information.\nCopyright © 2009-2021 The University of Edinburgh and contributors\n","link":"https://docs.workflowfm.com/workflowfm-reasoner/","title":"WorkflowFM Reasoner"}]