[{"body":"The WorkflowFM Reasoner is implemented within the interactive theorem proving environment of HOL Light.\nIt also depends on 3 additional libraries that need to be present in the HOL Light directory.\nWe have a repository set up for a quick configuration, or you can install everything manually.\n","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/install/","title":"Installation"},{"body":"Quick setup Clone the following repository: https://github.com/workflowfm/hol-light\n1git clone https://github.com/workflowfm/hol-light.git Then make sure all the submodules are initialised and updated:\n1git submodule update --init --recursive Manual setup Assuming an existing installation of HOL Light, you can setup the reasoner manually by installing the following libraries:\n The Isabelle Light library. This also comes bundled with HOL Light by default. Additional HOL Light tools. This consists of useful snippets of code, libraries, and theorems. This should be installed in a tools/ directory within HOL Light. The HOL Light embed library which enables reasoning with encoded logics. This should be installed in a embed/ directory within HOL Light.  It is important to use the correct directory names, as the reasoner will seek to load specific files from each library.  Finally, install the reasoner itself by cloning the repository to a workflowfm/ directory within HOL Light:\n1git clone https://github.com/workflowfm/workflowfm-reasoner.git worklfowfm ","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/install/setup/","title":"Setup"},{"body":"You can install HOL Light by following its standard installation instructions.\nWe have included our own notes below in case they are helpful.\nSpecific tips for DICE users at the University of Edinburgh are included below.  Install OCaml OCaml 4.07.0 minimum is required. The easiest way to install this is through opam.\nOn DICE, opam can be compiled from source and installed locally. It is better to use a locally installed OCaml than the centrally available one.  You also need to install the `num` and `camlp5` packages:\n1opam install num camlp5 In many cases (including on DICE) the toplevel loads camlp4. In order to load camlp5 by default, you need to edit the .ocamlinit file in your home directory (opam usually creates one, otherwise add it yourself). Add the following to that file:\n1#use \u0026#34;topfind\u0026#34;;; 2#require \u0026#34;camlp5\u0026#34;;; 3#load \u0026#34;camlp5o.cma\u0026#34;;; Running ocaml should give you a Camlp5 parsing version ... at the end.\nRun HOL Light To install/run HOL Light, first create the pa_j.ml file:\n1make The run ocaml and load HOL Light:\n1#use \u0026#34;hol.ml\u0026#34;;; Checkpointing Checkpointing eliminates loading times, which are otherwise relatively long, especially when you need to restart HOL Light during development.\nWe have been using DMTCP. Unfortunately, newer versions seem to be failing with HOL Light in a number of different platforms, but it is still worth trying.\nVersion 2.0.0 and above does not seem to work on DICE. Try version 1.2.4.  Once you have installed DMTCP, you can create the checkpoint as follows:\n1dmtcp_checkpoint ocaml Then load HOL Light as usual:\n1#use \u0026#34;hol.ml\u0026#34;;; Wait for it to finish, then open a new terminal and checkpoint:\n1dmtcp_command -c There is no notification when the checkpoint is complete other than the appearance of the dmtcp_restart_script.sh shortcut. You can then kill/exit OCaml.\nRunning dmtcp_restart_script.sh should load the checkpoint from where you left it. Issue a command to HOL Light/OCaml to make sure it works.\nSubsequent uses of dmtcp_command -c will update your checkpoint.\n","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/install/hol-light/","title":"Install HOL Light"},{"body":"Once you have HOL Light up and running, you can load the reasoner in console mode using the following command:\n1loads (!hol_dir ^ \u0026#34;/workflowfm/make.console.ml\u0026#34;);; If you need to use the JSON mode, you can use this command instead:\n1loads (!hol_dir ^ \u0026#34;/workflowfm/make.ml\u0026#34;);; ","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/install/load/","title":"Loading the reasoner"},{"body":"This section covers some basic elements, concepts, and terminology used in the WorkflowFM Reasoner. This includes logical terms, process specifications, composition actions, and much more.\n","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/elements/","title":"Elements"},{"body":"Processes are specified based on their input and output resources. Each resource is specified by its type and a π-calculus channel that receives or sends it.\nResource types Resource types are specified by a proposition in linear logic. In HOL Light these are propositions of type `:LinProp`.\nResource type names need to follow the same naming restrictions as HOL Light variables, i.e. they need to start with a letter and contain only letters and numbers.  Resource types can be composed using the following logical connectives:\n   Connective HOL Light Syntax Interpretation     A ⊗ B A ** B Two resources A and B in parallel.   A ⊕ B A ++ B Optional resource of either type A or B (not both).    Different combinations of these operators can be used to express composite resource types of arbitrary complexity.\nTypically, composite resource types involving these 2 operators represent output resources. In contrast, input resources are expressed as the negation of output resources, using the operator NEG.\nFor example, this means the type `NEG (A ** B)` represents two parallel input resources.\nNegated duals of the ⊗ and ⊕ operators do exist and are as follows:\n   Connective Dual HOL Light Syntax     A ⊗ B A ⅋ B A % B   A ⊕ B A \u0026amp; B A \u0026amp; B    For example, this makes the followning expressions equivalent: NEG (A ** B) = NEG A % NEG B\nHowever, the reasoner is developed to work with polarized types, i.e. resource types that only use the ⊗ and ⊕ connectives and the negations of such types.\nMixing up input and output connectives and arbitrary negations may lead to unpredictable results.  This means that, for process specification and composition, you are expected to use atomic resource types or composite ones with the ⊗ and ⊕ operators. If you need to explicitly state that a resource type is an input, then negate the whole term using NEG().\nThe reasoner often allows you to not even use NEG when a resource type is unambiguously expected to be an input.\nAll binary operators are right-associative. For example: A ** B ** C = A ** (B ** C).  Channels Each resource type in a process specification is either received (input) or sent (output) through a π-calculus channel. Generally, the reasoner aims to minimize the user's interaction with π-calculus components. In the case of channels, the reasoner will automatically generate appropriate channel names for each resource. We present the channel syntax here for reference when it appears in various results.\nWe say that a resource type or proposition is annotated with a π-calculus channel to form a term.  At a high level, annotations simply appear as pairs of resource types and channels.\nAt the logic level, the corresponding type of a term in HOL Light is `:(num)LinTerm`.\nNote the use of numbers (num) in that type. This represents the type of channels, which in principle could be any desired HOL Light type. Numbers make many reasoning tasks easier, though for the most part in practice we work with named variables for channels.\nResource annotation is accomplished in the logic with the HOL Light operator \u0026lt;\u0026gt;.\nFor example, the term `(A ** B) \u0026lt;\u0026gt; c` represents a channel c carrying an output resource of type A ** B or, more specifically, two output resources of type s A and B respectively in parallel.\n","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/elements/resources/","title":"Resources"},{"body":"Processes are defined based on their input and outputs resources, as well as some additional metadata.\nThe full process data structure is the following:\n1module type Process_type = 2sig 3 type t = { 4 name : string; 5 inputs : (term * term) list; 6 output : term * term; 7 prov : provtree; 8 proc : term; 9 actions : Action.t list; 10 copier : bool; 11 intermediate : bool; 12 } 13(* ... *) 14end;; Each process is assumed to have a unique name. Attempting to construct a composite process with the same name as one of its components will result in a failure.\nResource type names need to follow the same naming restrictions as HOL Light variables, i.e. they need to start with a letter and contain only letters and numbers.  Here is an example atomic process P with 2 inputs, X ++ Y and Z, and an output of type A ** B ** C (or 3 parallel outputs of types A, B, and C):\n1{name = \u0026#34;P\u0026#34;; 2 inputs = [(`X ++ Y`, `cP_lB_X_Plus_Y_rB_1`); (`Z`, `cP_Z_2`)]; 3 output = (`A ** B ** C`, `oP_lB_A_x_lB_B_x_C_rB_rB_`); 4 prov = 5 Provnode (\u0026#34;times\u0026#34;, Provleaf \u0026#34;P\u0026#34;, 6 Provnode (\u0026#34;times\u0026#34;, Provleaf \u0026#34;P\u0026#34;, Provleaf \u0026#34;P\u0026#34;)); 7 proc = 8 `P (cP_lB_X_Plus_Y_rB_1,cP_Z_2,oP_lB_A_x_lB_B_x_C_rB_rB_) = 9 Comp 10 (Res [cP_lB_X_Plus_Y_rB_1__opt_X; cP_lB_X_Plus_Y_rB_1__opt_Y] 11 (Out cP_lB_X_Plus_Y_rB_1 12 (* ... *) 13 ))`; 14 actions = []; copier = false; intermediate = false} We explain each of the fields next.\nInput / Output Input and output resources are described as annotated terms (see resources). More specifically, each resource is a pair of terms (term * term), the first one being the resource type and the second one the associated channel.\nChannel names are generated automatically, yielding some fairly verbose names such as oP_lB_A_x_lB_B_x_C_rB_rB_ seen in the example above.\nEach process can have a list of input resources and a single, potentially composite output resource.  Provenance The prov field captures the output provenance for the process. See Provenance for more details.\nπ-calculus The proc field captures the π-calculus process definition. This describes the process in an executable term of asynchronous communication through the available channels.\nIt involves a process definition as a function over the free channels, i.e. the channels involved in the inputs and outputs.\nFor atomic processes, the body of the definition is constructed automatically based on the input and output specification. It essentially provides a typechecked term for parallel reception of all the inputs and sending of the output.\nFor composite processes, the body of the definition is constructed via proof, with all the associated guarantees of correctness.\nActions Composite processes include a list of composition actions that were used to construct them.\nThis allows us to reconstruct or revalidate these composite processes at any point, for instance after updating the specification of one of their components. It also allows us to reload all the intermediate steps of the composition to be able to construct different variations without going through all of the same steps.\nAtomic processes have an empty list of actions.\nCopy Nodes Copier processes or Copy Nodes are processes that represent the ability of a particular resource, such as an electronic document, to be copied.\nWe do not include exponentials in our linear logic formalisation, so this mechanism enables us to copy resources in an explicit way. If it is not actually possible to copy a resource (e.g. a physical resource or currency), then it will not be possible to provide a concrete implementation of the specification of the copier process.\nMore specifically, Copy Nodes are processes that receive a single input (e.g. A) and provide several copies of the same resource (e.g. A ** A ** A).\nThe copier field automatically identifies processes with a Copy Node specification.\nThis may also catch processes with a Copy Node specification but a different intended purpose (e.g. a process that splits a document in half and yields two different documents). At the logical level it is not possible to disambiguate between the two.\nNonetheless, Copy Nodes are not treated any differently than normal processes by the reasoner. This field is only a flag to facilitate the identification of processes with this type of specification. For instance, this is useful in our diagrammatic composer tool, where Copy Nodes are depicted with a special round symbol.\nIntermediate Processes Composite processes are differentiated into intermediate and stored processes.\nEvery time a composition action is performed between 2 processes, an intermediate composite process is produced. Subsequent composition steps will produce further intermediate processes. Once a composition is completed, we store the final process among the other atomic processes and completed compositions. The intermediate processes can then be deleted, to keep the list of available processes short.\nAs the size of the composed workflows increases, a large number of intermediate processes may be produced. Separating intermediate from stored processes enables better housekeeping and a smoother user interaction. Besides, the user has the option to store every single intermediate process produced if they so choose.\nOther than managing the processes at the user level, the reasoner does not treat intermediate processes any differently than atomic or stored processes.\n","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/elements/processes/","title":"Processes"},{"body":"Composition is achieved through binary actions that compose 2 processes together. Although there is some high level user control over the actions, the composition is automated and strictly follows the rules of linear logic.\nThe result is an intermediate composite process specified by its input and output resources and a correct-by-construction, executable π-calculus definition. These processes can then be further composed using subsequent actions.\nPerforming an action involved the production and maintenance of a temporary internal state called an actionstate. This provides additional metadata about how a composition was achieved.\nActions Binary composition actions have the following structure:\n1module Action = struct 2 3 type t = { 4 act : string; 5 larg : string; 6 lsel : string; 7 rarg : string; 8 rsel : string; 9 res : string ; 10 } 11 12(*...*) 13end;; The fields can be described briefly as follows:\n   Field Description     act The name of the composition action to be performed.   larg The name of the first process (or left-hand-side) to be composed.   lsel A selector argument for the first process.   rarg The name of the second process (or right-hand-side) to be composed.   rsel A selector argument for the second process.   res The desired name for the resulting composite process.    By default there are 3 available composition actions:\n TENSOR: Parallel composition. WITH: Conditional composition. JOIN: Sequential composition.  These are described in more detail below.\nEach action is associated with an implemented reasoning process (or tactic) in HOL Light. There is an internal associative map between tactic names and their actual implementation.\nThese reasoning processes follow the rules of linear logic in a formally verified way, with the associated guarantees of correctness we have discussed. This may sometimes lead to results in terms of input and output types for the composite process that may be more complex than expected. Though such results may seem unintuitive at first, their correctness is mathematically guaranteed, with an enforced systematic accounting of all resources (linearity). Small examples of this appear in our description of the actions below.\nSelector arguments allow users to specify a specific part of each composed process. These arguments have a different use in each action, but allow a high level of user control.\nParallel - TENSOR The TENSOR action composes two processes in parallel. This results in a composite process with all the inputs of both processes and their two outputs composed in a single parallel output.\nIts name corresponds to the ⊗ operator (pronounced times or tensor), which denotes parallel resources.\nSelector arguments Selector arguments are unused in the TENSOR action.\nExample As an example, the result R of the parallel composition of a process P with input X and output A ++ B and a process Q with inputs Y and Z and output C is the following process:\n1{name = \u0026#34;R\u0026#34;; 2 inputs = [(`X`, `cP_X_1`); (`Y`, `cQ_Y_1`); (`Z`, `cQ_Z_2`)]; 3 output = (`(A ++ B) ** C`, `c_Step0___Step0__z1`); 4 prov = 5 Provnode (\u0026#34;times\u0026#34;, Provnode (\u0026#34;plus\u0026#34;, Provleaf \u0026#34;P\u0026#34;, Provleaf \u0026#34;P\u0026#34;), 6 Provleaf \u0026#34;Q\u0026#34;); 7 proc = 8 `R (cP_X_1,cQ_Y_1,cQ_Z_2,c_R___R__z1) = 9 PiTimesProc (A ++ B) C c_R___R__z1 oP_lB_A_Plus_B_rB_ oQ_C_ 10 (P (cP_X_1,oP_lB_A_Plus_B_rB_)) 11 (Q (cQ_Y_1,cQ_Z_2,oQ_C_))`; 12 actions = 13 [{Action.act = \u0026#34;TENSOR\u0026#34;; larg = \u0026#34;P\u0026#34;; lsel = \u0026#34;\u0026#34;; rarg = \u0026#34;Q\u0026#34;; rsel = \u0026#34;\u0026#34;; 14 res = \u0026#34;R\u0026#34;}]; 15 copier = false; 16 intermediate = true} The action used can be noticed in the actions field above and is as follows:\n1{Action.act = \u0026#34;TENSOR\u0026#34;; larg = \u0026#34;P\u0026#34;; lsel = \u0026#34;\u0026#34;; rarg = \u0026#34;Q\u0026#34;; rsel = \u0026#34;\u0026#34;; res = \u0026#34;R\u0026#34;} Conditional - WITH The WITH action composes two processes conditionally.\nMore specifically, given an input X of a process P and a Y input of a process Q, their conditional composition yields a process with an optional input X ++ Y, i.e. one that can accept X or Y (but not both). If the composite process receives X then P will be executed. Otherwise if the composite process receives Y then Q will be executed.\nIts name corresponds to the \u0026amp; operator (pronounced with), which denotes optional input resources.\nSelector arguments Selector arguments are used in the WITH action to specify which inputs should be used in the composite conditional input. The user needs to provide the resource type of the input to be used from each process.\nThere is no differentiation between distinct inputs with the same resource type. If multiple inputs with the same type exist in the same component process, this may result to the wrong one being used to form the condition. There is currently no way to affect this outcome.  Example As an example, the result R of the conditional composition of a process P with input X and output A ++ B and a process Q with inputs Y and Z and output C with inputs X and Y selected is the following process:\n1{name = \u0026#34;R\u0026#34;; 2 inputs = [(`Z`, `cQ_Z_2`); (`X ++ Y`, `c_R___R__x3`)]; 3 output = (`((A ++ B) ** Z) ++ C`, `c_R___R__y3`); 4 prov = 5 Provnode (\u0026#34;plus\u0026#34;, 6 Provnode (\u0026#34;times\u0026#34;, 7 Provnode (\u0026#34;plus\u0026#34;, Provleaf \u0026#34;\u0026amp;_R\u0026#34;, Provleaf \u0026#34;\u0026amp;_R\u0026#34;), 8 Provleaf \u0026#34;\u0026amp;_R\u0026#34;), 9 Provleaf \u0026#34;\u0026amp;_R\u0026#34;); 10 proc = (*...*); 11 actions = 12 [{Action.act = \u0026#34;WITH\u0026#34;; larg = \u0026#34;P\u0026#34;; lsel = \u0026#34;X\u0026#34;; rarg = \u0026#34;Q\u0026#34;; rsel = \u0026#34;Y\u0026#34;; 13 res = \u0026#34;R\u0026#34;}]; 14 copier = false; 15 intermediate = true} The action used can be noticed in the actions field above and is as follows:\n1{Action.act = \u0026#34;WITH\u0026#34;; larg = \u0026#34;P\u0026#34;; lsel = \u0026#34;X\u0026#34;; rarg = \u0026#34;Q\u0026#34;; rsel = \u0026#34;Y\u0026#34;; res = \u0026#34;R\u0026#34;} It is worth noting the output type of the composite process, namely ((A ++ B) ** Z) ++ C. This is an optional output consisting of the outputs A ++ B and C of the two components, each of which may be produced depending on which process is executed at runtime.\nNote, however, that the output A ++ B is paired with a new output Z. This corresponds to the second input Z of Q. This needs to still be an input in the composite process R because without it Q would not be able to execute. However, if P is executed then the input Z will not be used.\nThe rules of linear logic guarantee that unused resources are accounted for and do not just disappear. This leads to Z appearing as an output parallel to the output of P.\nMerged inputs A notable case is one where the two conditionally composed processes have common inputs. In that case, the common inputs merge into inputs of the composite process.\nFor example, both composed processes may have an input of type A each. This means both processes require a resource of type A in order to execute. No matter which of the 2 processes ends up executing in the conditional execution at runtime, the composite process will require an input of type A.\nTherefore, the composite process will have a single A input. We call such an input a merged input. These are reported explicitly in the actionstate.\nSequential - JOIN The JOIN action composes two processes sequentially.\nMore specifically, given a selected sub-term of the output of the first process and a matching input of the second process, their sequential composition yields a composite process where the resource corresponding to the selected sub-term is connected from the output of the first process to the output of the second.\nA matching input is not necessarily one that matches exactly, but rather one that can accept the selected output sub-term. For instance, an input of type A ++ B can accept an output of type A.  Selector arguments The first/left selector argument is used in the JOIN action to select the output sub-term of the first/left process.\nThis is specified as a path in the syntax tree of the process's output. It should follow the syntax of HOL Light's find_path function.\nIn short, the string lr means we should take the left path in the syntax tree, whereas the string r means we should take the right. An empty string indicates we should consider the type of the whole output.\nFor example, given an output A ** (B ++ C) we can select any sub-term as follows:\n   Sub-term Selector string     A lr   B rlr   C rr   B ++ C r   A ** (B ++ C) (empty)    The second/right selector argument is used to select the input type of the second/right process that is expected to match our selected sub-term. This can help disambiguate between 2 inputs that are both able to receive the selected output type.\nExample As an example, the result R of the sequential composition of a process P with input X and output A ++ B and a process Q with inputs A and Y and output C is the following process:\n1{name = \u0026#34;R\u0026#34;; 2 inputs = [(`X`, `cP_X_1`); (`Y`, `cQ_Y_2`)]; 3 output = (`C ++ (Y ** B)`, `c_R___R__y3`); 4 prov = 5 Provnode (\u0026#34;plus\u0026#34;, Provleaf \u0026#34;Q\u0026#34;, 6 Provnode (\u0026#34;times\u0026#34;, Provleaf \u0026#34;Q:cQ_Y_2\u0026#34;, Provleaf \u0026#34;P\u0026#34;)); 7 proc = (* ... *); 8 actions = 9 [{Action.act = \u0026#34;JOIN\u0026#34;; larg = \u0026#34;P\u0026#34;; lsel = \u0026#34;lr\u0026#34;; rarg = \u0026#34;Q\u0026#34;; rsel = \u0026#34;A\u0026#34;; res = \u0026#34;R\u0026#34;}]; 10 copier = false; 11 intermediate = true} The action used can be noticed in the actions field above and is as follows:\n1{Action.act = \u0026#34;JOIN\u0026#34;; larg = \u0026#34;P\u0026#34;; lsel = \u0026#34;lr\u0026#34;; rarg = \u0026#34;Q\u0026#34;; rsel = \u0026#34;A\u0026#34;; res = \u0026#34;R\u0026#34;} Notes There are many different possible cases of interesting sequential compositions and edge cases. Depending on their types there may also be multiple ways that two specific processes can be composed together sequentially.\nIn our experience, it is not easy or practical for the user to control the sequential composition in such a fine grained way. Instead, the reasoner uses a set of heuristics to make its own decisions based on 2 key goals:\n Connect the 2 processes maximally: The reasoner attempts to connect as many of the inputs resources of the receiving process as possible. Minimize the execution steps in the final composition: The reasoner aims to make as few reasoning steps as possible, minimize the number of resources that are buffered (i.e. forwarded explicitly from one process to the next), and reduce repeating resources.  The first goal means that if the left process has output A ** B ** C and the right process has inputs B and C, then both of the two inputs will be connected to their respective parallel outputs irrespective of the user selection.\nThe second goal affects multiple decisions in the sequential composition.\nOne example is when the optional output of the left process is converted to an optional output with identical options, such as Y ++ Y. This might occur for example when a process that may fail to produce resource Y and throw an exception is composed with a contingency process that can recover from the exception and produce Y after all. The reasoner will attempt to collapse that output to a single Y output, whether that is the result of the original or of the contingency process. In fact, this will also reduce the reasoning steps and the size of the generated executable term, making it more efficient. It may also reduce the branching in subsequent compositions further down the line.\nThe tradeoff is that it is no longer possible to determine whether Y was produced from the original component or from the contingency process, which may be useful in some cases. The reasoner makes this decision under the assumption that if such differentiation is to be made between the produced Y resources, it should be reflected in the their respective types, instead of them having the same type Y.\nActionstate Each composition action corresponds to a reasoning tactic implemented in HOL Light. These tactics require an extended proof state to function appropriately. This extension is captured using the Actionstate structure.\nThe user is not required to manipulate the actionstate themselves, unless they perform low level proofs. However, the actionstate does appear as a result of a composition action and carries additional metadata.  The final actionstate resulting from a composition proof is provided within the reasoner's response, so it may be useful to explain its structure briefly here.\nThe Actionstate structure is defined as follows:\n1module Actionstate = struct 2 type t = { 3 label : string; 4 ctr : int; 5 metas : term list; 6 merged : (term * string * string) list; 7 iprov : (term * provtree) list; 8 prov : (string * provtree) list; 9 } 10 11(* ... *) 12end;; The fields can be described briefly as follows:\n   Field Description     label A unique name for the given composition, typically the name of the resulting process.   ctr A unique counter for each reasoning step during composition.   metas A list of metavariables used during composition.   merged A list of merged inputs during a conditional composition.   iprov \u0026amp; prov Provenance tracking for inputs and outputs respectively.    The unique name and counter are used to guarantee uniqueness of introduced channel names.\nMerged inputs occur during conditional composition, when both processes have the same input type, so that the final composition does not duplicate inputs. Each entry consists of the input term as it appears in the composition paired with the names of the 2 input channels that got merged.\n","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/elements/composition/","title":"Composition"},{"body":"This section covers the use of the reasoner through the console command interface running at the OCaml/HOL Light toplevel. This includes the available commands and responses.\nThe JSON API mode can be loaded using the following command:\n1loads (!hol_dir ^ \u0026#34;/workflowfm/make.console.ml\u0026#34;);; The entire interface is structured as the following module type:\n1module type Composer_console_type = 2 sig 3 module Composer : Composer_type 4 5 val responses : unit -\u0026gt; Composer.Response.t list 6 7 val add_process : Composer.Process.t -\u0026gt; Composer.Process.t 8 val get_process : string -\u0026gt; Composer.Process.t 9 val exists_process : string -\u0026gt; bool 10 val del_process : string -\u0026gt; unit 11 val reset_processes : unit -\u0026gt; unit 12 val list : unit -\u0026gt; string list 13 14 val add_intermediate : Composer.Process.t -\u0026gt; Composer.Process.t 15 val get_intermediate : string -\u0026gt; Composer.Process.t 16 val exists_intermediate : string -\u0026gt; bool 17 val del_intermediate : string -\u0026gt; unit 18 val reset_intermediates : unit -\u0026gt; unit 19 val ilist : unit -\u0026gt; string list 20 21 val get : string -\u0026gt; Composer.Process.t 22 23 val resetstep : unit -\u0026gt; unit 24 val reset : unit -\u0026gt; unit 25 val full_reset : unit -\u0026gt; unit 26 27 val create : string -\u0026gt; term list -\u0026gt; term -\u0026gt; Composer.Response.t 28 val compose1 : Action.t -\u0026gt; Composer.Response.t 29 val tensor : string -\u0026gt; string -\u0026gt; Composer.Response.t 30 val cwith : string -\u0026gt; string -\u0026gt; string -\u0026gt; string -\u0026gt; Composer.Response.t 31 val join : string -\u0026gt; string -\u0026gt; string -\u0026gt; string -\u0026gt; Composer.Response.t 32 33 val store : string -\u0026gt; string -\u0026gt; Composer.Response.t 34 val load : string -\u0026gt; unit 35 end ;; Each of these functions/commands is explained in more detail in the next sections.\n","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/console/","title":"Console"},{"body":"When composing processes, it is often necessary to keep track of which component processes own the inputs and outputs (or rather the different parts of the single output) of a composite process. We call this information provenance.\nFor example, provenance can provide essential metadata to be able to correctly visualize a composite process diagrammatically.\nExample We begin with a motivating example to explain the purpose that provenance fulfils for the visualization of resource-based composition.\nSpecification Assume the following process specifications:\n P1: ⊢ NEG X, A ⊗ B P2: ⊢ NEG B, C ⊕ D Q1: ⊢ NEG A, E Q2: ⊢ NEG E, NEG (C ⊕ D), Y  We then perform JOIN operations for each pair, obtaining the following intermediate compositions:\n P: ⊢ NEG X, A ⊗ (C ⊕ D) Q: ⊢ NEG A, NEG (C ⊕ D), Y  Finally, we JOIN the 2 results to obtain the final composition:\n R: ⊢ NEG X, Y  Visualization At the logical level, the composition above seems straightforward. The visualization, however, needs to reveal more information. We need to accurately depict how the individual components are connected to each other, and how resources flow between them.\nThe image below shows the following processes in this order: P1, P2, P, Q, and R.\n In the visualization of R, the system has inferred that resource A connects P1 to Q1, whereas P2 and Q2 are connected by C ⊕ D. This is achieved despite the fact that the last composition action joined intermediate processes P and Q, meaning the whole term A ⊗ (C ⊕ D) was \u0026quot;cut\u0026quot; in one go.\nThis is accomplished by tracking the input and output provenance of the involved processes. Specifically, when composing P, we track its output provenance for the output A ⊗ (C ⊕ D) is one where A came from P1 and (C ⊕ D) came from P2. Similarly, when composing Q, we track the input provenance, i.e. that NEG A belongs to Q1 and NEG (C ⊕ D) belongs to Q2. This way, when P and Q are joined, we know exactly where each connected resource is coming from and going to.\nProvenance Trees We want to be able to track provenance of specific CLL resources. This means subterms of the same term can have different provenance. For this reason, we track provenance using a binary tree structure that matches the syntax tree of the term. The leaves of the tree contain provenance values instead of CLL propositions.\nHere is the syntax and provenance trees for the output of P from the example:\n1⊗ ⊗ 2|\\ |\\ 3| \\ | \\ 4A ⊕ P1 ⊕ 5 |\\ |\\ 6 | \\ | \\ 7 C D P2 P2 If all the propositions in a (sub)tree have the same provenance, we can collapse the provenance (sub)tree to a single node:\n1⊗ ⊗ 2|\\ |\\ 3| \\ | \\ 4A ⊕ P1 P2 5 |\\ 6 | \\ 7 C D In the reasoner, provenance trees are defined with a custom data type as follows:\n1type provtree = 2 Provnode of string * provtree * provtree 3 | Provleaf of string;; Nodes of ⊗ are labelled \u0026quot;times\u0026quot;, while ⊕ nodes are labelled \u0026quot;plus\u0026quot;.\nBased on this, the above example provenance tree would be represented as Provnode (\u0026quot;times\u0026quot;, Provleaf \u0026quot;P1\u0026quot;, Provleaf \u0026quot;P2\u0026quot;).\nOutput Provenance Each process may only have a single, possibly composite output. When composing processes, the output of the composition often consists of parts of the outputs of its components.\nIn our example above, P has output A ⊗ (C ⊕ D) consisting of A coming from P1 and C ⊕ D coming from P2. This is exactly what the provenance tree represents.\nThe output provenance tree of each process is stored in its structure and used during composition. It is also copied as an output provenance entry, which maps each process name to its output provenance, in the composition state. This allows the composition tactics to gain access to that information.\nApart from names of component atomic (or collapsed composite) processes who own part of the output, the leaves of an output provenance tree may have special values as described next.\nThe \u0026amp; prefix Provenance leaves starting with a \u0026amp; prefix indicate a \u0026quot;merge node\u0026quot; as the source of the output.\nWhen using WITH and in some cases of optional outputs in JOIN we need to introduce a \u0026quot;merge node\u0026quot; to indicate that 2 (or more) outputs are merged into a single (usually optional) output. This is one way of showing how the options come together, without showing disconnected outputs from different processes.\nOutputs coming out of such a merge node can no longer be linked back to the components they came from without breaking the correlation between the options.\nIn other cases, two equivalent options are merged into a single output as an \u0026quot;optimization\u0026quot; step to avoid redundant case splits. A merge node is also used here, and the merged output has an unclear (double?) provenance.\nPerhaps the simplest example is shown below:\n In this, the second option E of P is converted to the type of the first option A through Q. This fits the intuition of a recovery process that recovers from an exception E to produce an expected A. The result of the composition is a single A output, whether it came from P in the first place or from Q after \u0026quot;recovery\u0026quot;.\nIf A gets connected to another process, whether the source will be P or Q is only determined at runtime. We therefore use the \u0026amp; merge node and label the output provenance to represent that the A output will be coming from this particular merge node.\nIn such cases we mark the provenance of the new output using \u0026amp; followed by the name of the composition that introduced the merge node.\nUnused inputs and the : tag When dealing with optional outputs, the JOIN action often needs to build buffers for unused inputs. See the standard example below:\n What should the output provenance for B be? Here it clearly should be Q. However, Q may not be atomic, but an intermediate composition instead. The reasoner does not know whether Q is composed of multiple components and which component B is coming from.\nMirroring the image above, here are 2 examples where Q is a composite process consisting of Q1 and Q2 (top) and Q3 and Q4 (bottom):\n In the top case, B is an input of Q2, whereas in the bottom case B is an input of Q3. In both cases, the reasoner just sees an intermediate composition Q with inputs B and E and output Y as in the previous image. We therefore need a different way of tagging the provenance of B in a way that allows us to trace it back to Q2 or Q3.\nThis is accomplished by reporting the channel c of the unused input B. In the example above, the reasoner will produce a provenance leaf Q:c, i.e. the name of the (possibly composite) process Q followed by a colon : followed by the name of the channel of the unused input c.\nThe reasoner is effectively telling the graph interface to search in the process Q for an input with channel c and use the owner of that input as the source of B.\nThis may cause issues when multiple identical components introduce the same channel name multiple times in the same composition. The reasoner does not currently diambiguate between those because it does not even have that information.\nInput Provenance Each process can have multiple inputs, each with its own unique channel. This means we can generally track the owner of an input through the channel.\nIn our example above, NEG (C ⊕ D) of Q2 will have a unique channel name, let's assume cQ. When composing Q1 with Q2, this input is not affected. This means if we try to connect something to it, we already know cQ belongs to Q2 so we can track its provenance and connect the graph appropriately.\nThe composition actions only affect input channels in 2 ways:\n The WITH action constructs new inputs that are options or merges of other inputs. These are reported in the composition step and their provenance is linked to the composite process, not its components. The JOIN action manipulates inputs in order to match the output of the other (left) component. This includes adding buffers, using inputs from different components and merging options. In this case, we need to track the provenance of each part in the constructed input.  Back to our example, when composing P with Q, we connect NEG A with NEG (C ⊕ D) to create a new input NEG (A ⊗ (C ⊕ D)) that matches the output of P. At that point, we need to track that NEG A had some channel cP which can be traced back to P, whereas NEG (C ⊕ D) had channel cQ that we know belongs to Q. For this reason, we build the following provenance tree (shown next to the input parse tree), while ignoring the negation:\n1⊗ ⊗ 2|\\ |\\ 3| \\ | \\ 4A ⊕ cP ⊕ 5 |\\ |\\ 6 | \\ | \\ 7 C D cQ cQ Note that the leaves of an input provenance tree, in principle, contain channels as opposed to those of an output provenance tree which contain process names.\nThere are a few particularities and special cases of leaves for input provenance, which we describe next.\nDisambiguating same channels with a : tag Assume a process Q with an input A ⊕ B on channel cQ. In the image shown below, we TENSOR Q with itself and then JOIN it with a process P with output (A ⊕ B) ⊗ (A ⊕ B):\n As we are joining P to the the 2 Q processes, the reasoner will apply the par rule to compose the 2 A ⊗ B inputs into one that matches the output of P. Sticking to the explanation of input provenance we provided above, the input provenance for the composite input will be (cQ ⊕ cQ) ⊗ (cQ ⊕ cQ).\nThis would lead the graph engine to look for 4x cQ channels and fail because there are only 2 available, one for each instance of Q. The reasoner needs to somehow convey the information that the first 2 cQ channels in the provenance tree refer to the same channel, whereas the other 2 cQ channels refer to a single other channel.\nThis is accomplished by tagging each channel in the provenance tree with an integer. If 2 leaves in the provenance tree have the same channel and same number, they refer to the same, single channel. If hey have the same channel name, but a different number, they refer to 2 separate instances of that channel. Note that the actual number used has no other significance and is merely linked to an internal proof counter.\nIn our example, the reasoner will report an input provenance (cQ:4 ⊕ cQ:4) ⊗ (cQ:7 ⊕ cQ:7) (or some other numbers instead of 4 and 7). This is how the graph engine that generated the image above knew how to connect one A and one B to the top Q, corresponding to channel cQ:4, and the other A and the other B to the second Q, corresponding to channel cQ:7.\nThe # provenance In some cases, an input being connected does not feed to any (atomic) process, but belongs to a buffer that is introduced. Such an input will be forwarded to the output of the composite process without change.\nThe reasoner reports the input provenance of such buffers using a hash # label for the leaf.\nIn our current composer implementation, we use a triangle \u0026quot;join\u0026quot; (or \u0026quot;terminator\u0026quot;) node as a target to connect buffered resources to.\nThe \u0026amp; prefix The issue of merged options in output provenance needs to be dealt with in input provenance too.\nLet's revisit the same example:\n As we are joining P and Q, the reasoner constructs an optional input A ⊕ E for Q using its existing input E and introducing a buffer of type A. Once the new input is constructed, we need to provide its input provenance. This must be such that E gets connected to Q, whereas A is connected to the merge node.\nThe reported input provenance is \u0026amp;_Step1 ⊕ cQ:5, where _Step1 the name of the composition, cQ the input channel of Q, and 5 some integer.\nFuture Work Further clarifying and simplifying the provenance information is an obvious want for the future.\nA few particularities exist because of the violation of channel uniqueness, so solving this problem in a more general way will help simplify provenance too.\nDepending on further developments and needs of the frontend graph engine, we may extend provenance labels. The fact that the leaves can have any string as a label makes this structure very flexible and expandable.\n","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/elements/provenance/","title":"Provenance"},{"body":"The console maintains an internal state of the introduced processes and compositions. This includes a list of atomic and stored processes and a separate list of intermediate processes. This allows the user to easily remove all intermediate processes when starting a new composition.\nGeneral The following commands are general purpose, spanning across the whole state:\n   Command Result     get \u0026quot;P\u0026quot; Returns the process named \u0026quot;P\u0026quot;, whether it is atomic, intermediate or stored.   reset() Resets intermediates and their step counter in order to start a new composition.   full_reset() Resets the entire state in order to start a fresh session from scratch.   load \u0026quot;P\u0026quot; Assuming a process named \u0026quot;P\u0026quot; is stored, the intermediate processes resulting from its composition steps are loaded.   store \u0026quot;_Step4\u0026quot; \u0026quot;P\u0026quot; Assuming an intermediate process named \u0026quot;_Step4\u0026quot; exists, it is stored as a new process named \u0026quot;P\u0026quot;.   responses() Yields the history of all responses given by the reasoner in the current session.    Commands that delete processes, such as reset() and full_reset() cannot be undone!  Notes:  The load command performs a reset() first.  Processes The list of atomic and stored processes can be managed with the following commands:\n   Command Result     add_process p Adds a new process to the list.   get_process \u0026quot;P\u0026quot; Retrieves the process named \u0026quot;P\u0026quot; if it exists.   exists_process \u0026quot;P\u0026quot; Returns true if a process named \u0026quot;P\u0026quot; exists.   del_process \u0026quot;P\u0026quot; Deletes the process named \u0026quot;P\u0026quot; from the list.   reset_processes() Resets the list by removing all processes.   list() Returns a list of the names of all processes.    Notes:  It is easier to use create rather than add_process so that the process specification is built automatically for you. The commands del_process and reset_processes should be avoided or, at least, used carefully. There is a risk of reaching an inconsistent state where the components of a composition have been deleted.  Intermediates The list of intermediate compositions can be managed with the following commands:\n   Command Result     add_intermediate p Adds a new intermediate process to the list.   get_intermediate \u0026quot;P\u0026quot; Retrieves the intermediate process named \u0026quot;P\u0026quot; if it exists.   exists_intermediate \u0026quot;P\u0026quot; Returns true if an intermediate process named \u0026quot;P\u0026quot; exists.   del_intermediate \u0026quot;P\u0026quot; Deletes the intermediate process named \u0026quot;P\u0026quot; from the list.   reset_intermediates() Resets the list by removing all intermediate processes.   ilist() Returns a list of the names of all intermediate processes.    Notes:  It is easier to use the composition commands rather than add_intermediate so that the process specifications are built automatically for you and mistakes are prevented. The command del_intermediate should be avoided or, at least, used carefully. There is a risk of reaching an inconsistent state where the components of a composition have been deleted. The use of the reset command is suggested instead of reset_intermediates.  Step counter Fresh names can be automatically produced for intermediate processes using the prefix \u0026quot;_Step\u0026quot; and a step counter.\nThe command resetstep() can be used to reset the step counter. However, the use of the reset command is suggested instead.\n","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/console/state/","title":"State"},{"body":"This section covers the main process specification and composition commands.\nIt is worth noting that the result of these commands is of type Composer.Response, which is defined as follows:\n1module Response : 2 sig 3 type t = 4 | Ping of float 5 | Create of Process.t 6 | Compose of Process.t * Action.t * Actionstate.t 7 | Verify of Process.t 8 | Deploy of string * (string * string * bool) list 9 | Failed of string 10 | Exception of string 11 (*...*) 12 end Upon failure a Failed or an Exception response will be issued with an associated message describing the failure. Otherwise, one of the other responses will be returned, as explained in the normal operation of each command below.\ncreate The create command constructs a new atomic process given the types of its desired inputs and output.\nIt takes 3 arguments:\n string: The name of the process. term list: The list of types of its inputs. term: The type of its output.  All terms are expected to be resources involving HOL Light propositions and the operators ++ and ** operators. No negative operators (NEG, \u0026amp;, %) should be used, including in the input types.\nThe command returns a Create response with the specification of the created process.\nNotes  Terms in HOL Light must be surrounded by back-ticks `. If a process with the same name already exists, a warning will be shown and the old process will be replaced. All the elements of the process other than its name and its types, including channel names, π-calculus specification, and provenance are constructed automatically.  Example The following invocation of create constructs a process named \u0026quot;P\u0026quot; with two inputs of types X and Y++Z respectively and an output of type A**B**C:\n1create \u0026#34;P\u0026#34; [`X`; `Y ++ Z`] `A ** B ** C`;; 1Console.Composer.Response.Create 2 {Console.Composer.Process.name = \u0026#34;P\u0026#34;; 3 inputs = [(`X`, `cP_X_1`); (`Y ++ Z`, `cP_lB_Y_Plus_Z_rB_2`)]; 4 output = (`A ** B ** C`, `oP_lB_A_x_lB_B_x_C_rB_rB_`); 5 prov = 6 Provnode (\u0026#34;times\u0026#34;, Provleaf \u0026#34;P\u0026#34;, 7 Provnode (\u0026#34;times\u0026#34;, Provleaf \u0026#34;P\u0026#34;, Provleaf \u0026#34;P\u0026#34;)); 8 proc = 9 `P (cP_X_1,cP_lB_Y_Plus_Z_rB_2,oP_lB_A_x_lB_B_x_C_rB_rB_) = 10 Comp (In cP_X_1 [cP_X_1__a_X] Zero) 11 (Comp 12 (Res [cP_lB_Y_Plus_Z_rB_2__opt_Y; cP_lB_Y_Plus_Z_rB_2__opt_Z] 13 (Out cP_lB_Y_Plus_Z_rB_2 14 [cP_lB_Y_Plus_Z_rB_2__opt_Y; cP_lB_Y_Plus_Z_rB_2__opt_Z] 15 (Plus 16 (In cP_lB_Y_Plus_Z_rB_2__opt_Y [cP_lB_Y_Plus_Z_rB_2_Y] 17 (In cP_lB_Y_Plus_Z_rB_2_Y [cP_lB_Y_Plus_Z_rB_2_l_a_Y] Zero)) 18 (In cP_lB_Y_Plus_Z_rB_2__opt_Z [cP_lB_Y_Plus_Z_rB_2_Z] 19 (In cP_lB_Y_Plus_Z_rB_2_Z [cP_lB_Y_Plus_Z_rB_2_r_a_Z] Zero))))) 20 (Res 21 [oP_lB_A_x_lB_B_x_C_rB_rB__A; oP_lB_A_x_lB_B_x_C_rB_rB__lB_B_x_C_rB] 22 (Out oP_lB_A_x_lB_B_x_C_rB_rB_ 23 [oP_lB_A_x_lB_B_x_C_rB_rB__A; oP_lB_A_x_lB_B_x_C_rB_rB__lB_B_x_C_rB] 24 (Comp 25 (Res [oP_lB_A_x_lB_B_x_C_rB_rB__l_a_A] 26 (Out oP_lB_A_x_lB_B_x_C_rB_rB__A [oP_lB_A_x_lB_B_x_C_rB_rB__l_a_A] 27 Zero)) 28 (Res [oP_lB_A_x_lB_B_x_C_rB_rB__rB; oP_lB_A_x_lB_B_x_C_rB_rB__rC] 29 (Out oP_lB_A_x_lB_B_x_C_rB_rB__lB_B_x_C_rB 30 [oP_lB_A_x_lB_B_x_C_rB_rB__rB; oP_lB_A_x_lB_B_x_C_rB_rB__rC] 31 (Comp 32 (Res [oP_lB_A_x_lB_B_x_C_rB_rB__rl_a_B] 33 (Out oP_lB_A_x_lB_B_x_C_rB_rB__rB [oP_lB_A_x_lB_B_x_C_rB_rB__rl_a_B] 34 Zero)) 35 (Res [oP_lB_A_x_lB_B_x_C_rB_rB__rr_a_C] 36 (Out oP_lB_A_x_lB_B_x_C_rB_rB__rC [oP_lB_A_x_lB_B_x_C_rB_rB__rr_a_C] 37 Zero)))))))))`; 38 actions = []; copier = false; intermediate = false} tensor The tensor command composes two processes in parallel with the TENSOR action.\nIt takes 2 arguments:\n string: The name of the first process to compose. string: The name of the second process to compose.  The command returns a Compose response with the specification of the created intermediate composition, the composition action that was applied, and the resulting actionstate with additional metadata.\nNotes  The name of the resulting intermediate composition is automatically determined using the \u0026quot;_Step\u0026quot; prefix and an internal step counter.  Example The following invocation of tensor performs the parallel composition _Step0 of a process P with input X and output A ++ B and a process Q with inputs Y and Z and output C:\n1create \u0026#34;P\u0026#34; [`X`] `A ++ B` ;; 2create \u0026#34;Q\u0026#34; [`Y`; `Z`] `C` ;; 3tensor \u0026#34;P\u0026#34; \u0026#34;Q\u0026#34; ;; 1Console.Composer.Response.Compose 2 ({Console.Composer.Process.name = \u0026#34;_Step0\u0026#34;; 3 inputs = [(`X`, `cP_X_1`); (`Y`, `cQ_Y_1`); (`Z`, `cQ_Z_2`)]; 4 output = (`(A ++ B) ** C`, `c_Step0___Step0__z1`); 5 prov = 6 Provnode (\u0026#34;times\u0026#34;, Provnode (\u0026#34;plus\u0026#34;, Provleaf \u0026#34;P\u0026#34;, Provleaf \u0026#34;P\u0026#34;), 7 Provleaf \u0026#34;Q\u0026#34;); 8 proc = 9 `_Step0 (cP_X_1,cQ_Y_1,cQ_Z_2,c_Step0___Step0__z1) = 10 PiTimesProc (A ++ B) C c_Step0___Step0__z1 oP_lB_A_Plus_B_rB_ oQ_C_ 11 (P (cP_X_1,oP_lB_A_Plus_B_rB_)) 12 (Q (cQ_Y_1,cQ_Z_2,oQ_C_))`; 13 actions = 14 [{Action.act = \u0026#34;TENSOR\u0026#34;; larg = \u0026#34;P\u0026#34;; lsel = \u0026#34;\u0026#34;; rarg = \u0026#34;Q\u0026#34;; rsel = \u0026#34;\u0026#34;; 15 res = \u0026#34;_Step0\u0026#34;}]; 16 copier = false; intermediate = true}, 17 {Action.act = \u0026#34;TENSOR\u0026#34;; larg = \u0026#34;P\u0026#34;; lsel = \u0026#34;\u0026#34;; rarg = \u0026#34;Q\u0026#34;; rsel = \u0026#34;\u0026#34;; 18 res = \u0026#34;_Step0\u0026#34;}, 19 {Actionstate.label = \u0026#34;_Step0\u0026#34;; ctr = 0; 20 metas = 21 [`c_Step0___Step0__z1`; `c_Step0___Step0__y1`; `c_Step0___Step0__Q1`; 22 `cQ_Y_1`; `cQ_Z_2`; `oQ_C_`; `cP_X_1`; `oP_lB_A_Plus_B_rB_`]; 23 merged = []; iprov = []; 24 prov = 25 [(\u0026#34;_Step0\u0026#34;, 26 Provnode (\u0026#34;times\u0026#34;, Provnode (\u0026#34;plus\u0026#34;, Provleaf \u0026#34;P\u0026#34;, Provleaf \u0026#34;P\u0026#34;), 27 Provleaf \u0026#34;Q\u0026#34;)); 28 (\u0026#34;P\u0026#34;, Provnode (\u0026#34;plus\u0026#34;, Provleaf \u0026#34;P\u0026#34;, Provleaf \u0026#34;P\u0026#34;)); 29 (\u0026#34;Q\u0026#34;, Provleaf \u0026#34;Q\u0026#34;)]}) cwith The cwith command composes two processes conditionally with the WITH action.\nIt takes 4 arguments:\n string: The name of the first process to compose. string: The type of the input to use from the first process. string: The name of the second process to compose. string: The type of the input to use from the second process.  The command returns a Compose response with the specification of the created intermediate composition, the composition action that was applied, and the resulting actionstate with additional metadata.\nNotes  The name of the resulting intermediate composition is automatically determined using the \u0026quot;_Step\u0026quot; prefix and an internal step counter. The types of the selected inputs need to be provided as strings and not as terms.  Example The following invocation of cwith performs the conditional composition _Step0 of a process P with input X and output A ++ B and a process Q with inputs Y and Z and output C with inputs X and Y selected:\n1create \u0026#34;P\u0026#34; [`X`] `A ++ B` ;; 2create \u0026#34;Q\u0026#34; [`Y`; `Z`] `C` ;; 3cwith \u0026#34;P\u0026#34; \u0026#34;X\u0026#34; \u0026#34;Q\u0026#34; \u0026#34;Y\u0026#34; ;; 1Console.Composer.Response.Compose 2 ({Console.Composer.Process.name = \u0026#34;_Step0\u0026#34;; 3 inputs = [(`Z`, `cQ_Z_2`); (`X ++ Y`, `c_Step0___Step0__x3`)]; 4 output = (`((A ++ B) ** Z) ++ C`, `c_Step0___Step0__y3`); 5 prov = 6 Provnode (\u0026#34;plus\u0026#34;, 7 Provnode (\u0026#34;times\u0026#34;, 8 Provnode (\u0026#34;plus\u0026#34;, Provleaf \u0026#34;\u0026amp;_Step0\u0026#34;, Provleaf \u0026#34;\u0026amp;_Step0\u0026#34;), 9 Provleaf \u0026#34;\u0026amp;_Step0\u0026#34;), 10 Provleaf \u0026#34;\u0026amp;_Step0\u0026#34;); 11 proc = 12 `_Step0 (cQ_Z_2,c_Step0___Step0__x3,c_Step0___Step0__y3) = 13 PiWithProc (NEG X) (NEG Y) c_Step0___Step0__x3 cP_X_1 cQ_Y_1 14 c_Step0___Step0__uI3 15 c_Step0___Step0__vI3 16 (PiPlusLProc ((A ++ B) ** Z) C c_Step0___Step0__y3 c_Step0___Step0__z1 17 c_Step0___Step0__uR3 18 c_Step0___Step0__vR3 19 (PiTimesProc (A ++ B) Z c_Step0___Step0__z1 oP_lB_A_Plus_B_rB_ 20 c_Step0___Step0__y1 21 (P (cP_X_1,oP_lB_A_Plus_B_rB_)) 22 (PiIdProc Z cQ_Z_2 c_Step0___Step0__y1 c_Step0___Step0__m2))) 23 (PiPlusRProc ((A ++ B) ** Z) C c_Step0___Step0__y3 oQ_C_ 24 c_Step0___Step0__uE3 25 c_Step0___Step0__vE3 26 (Q (cQ_Y_1,cQ_Z_2,oQ_C_)))`; 27 actions = 28 [{Action.act = \u0026#34;WITH\u0026#34;; larg = \u0026#34;P\u0026#34;; lsel = \u0026#34;X\u0026#34;; rarg = \u0026#34;Q\u0026#34;; rsel = \u0026#34;Y\u0026#34;; 29 res = \u0026#34;_Step0\u0026#34;}]; 30 copier = false; intermediate = true}, 31 {Action.act = \u0026#34;WITH\u0026#34;; larg = \u0026#34;P\u0026#34;; lsel = \u0026#34;X\u0026#34;; rarg = \u0026#34;Q\u0026#34;; rsel = \u0026#34;Y\u0026#34;; 32 res = \u0026#34;_Step0\u0026#34;}, 33 {Actionstate.label = \u0026#34;_Step0\u0026#34;; ctr = 0; 34 metas = 35 [`c_Step0___Step0__x3`; `c_Step0___Step0__uI3`; `c_Step0___Step0__vI3`; 36 `c_Step0___Step0__uR3`; `c_Step0___Step0__vR3`; `c_Step0___Step0__y3`; 37 `c_Step0___Step0__d3`; `c_Step0___Step0__uE3`; `c_Step0___Step0__vE3`; 38 `c_Step0___Step0__Q3`; `c_Step0___Step0__m2`; `c_Step0___Step0__z1`; 39 `c_Step0___Step0__y1`; `c_Step0___Step0__Q1`; `cQ_Y_1`; `cQ_Z_2`; 40 `oQ_C_`; `cP_X_1`; `oP_lB_A_Plus_B_rB_`]; 41 merged = [(`NEG (X ++ Y) \u0026lt;\u0026gt; c_Step0___Step0__x3`, \u0026#34;cP_X_1\u0026#34;, \u0026#34;cQ_Y_1\u0026#34;)]; 42 iprov = []; 43 prov = 44 [(\u0026#34;_Step0\u0026#34;, 45 Provnode (\u0026#34;plus\u0026#34;, 46 Provnode (\u0026#34;times\u0026#34;, 47 Provnode (\u0026#34;plus\u0026#34;, Provleaf \u0026#34;\u0026amp;_Step0\u0026#34;, Provleaf \u0026#34;\u0026amp;_Step0\u0026#34;), 48 Provleaf \u0026#34;\u0026amp;_Step0\u0026#34;), 49 Provleaf \u0026#34;\u0026amp;_Step0\u0026#34;)); 50 (\u0026#34;P\u0026#34;, Provnode (\u0026#34;plus\u0026#34;, Provleaf \u0026#34;P\u0026#34;, Provleaf \u0026#34;P\u0026#34;)); 51 (\u0026#34;Q\u0026#34;, Provleaf \u0026#34;Q\u0026#34;)]}) join The join command composes two processes in sequence with the JOIN action.\nIt takes 4 arguments:\n string: The name of the first process to compose. string: The path to a sub-term of the output of the first process. string: The name of the second process to compose. string: The type of the input to use from the second process.  The command returns a Compose response with the specification of the created intermediate composition, the composition action that was applied, and the resulting actionstate with additional metadata.\nNotes  The name of the resulting intermediate composition is automatically determined using the \u0026quot;_Step\u0026quot; prefix and an internal step counter. The path to a sub-type of the output of the first process must follow the syntax of HOL Light's find_path function. The types of the selected input need to be provided as a string and not as a term.  Example The following invocation of join performs the sequential composition _Step0 of a process P with input X and output A ++ B and a process Q with inputs A and Y and output C:\n1create \u0026#34;P\u0026#34; [`X`] `A ++ B` ;; 2create \u0026#34;Q\u0026#34; [`A`; `Z`] `C` ;; 3join \u0026#34;P\u0026#34; \u0026#34;lr\u0026#34; \u0026#34;Q\u0026#34; \u0026#34;A\u0026#34; ;; 1Console.Composer.Response.Compose 2 ({Console.Composer.Process.name = \u0026#34;_Step0\u0026#34;; 3 inputs = [(`X`, `cP_X_1`); (`Z`, `cQ_Z_2`)]; 4 output = (`C ++ (Z ** B)`, `c_Step0___Step0__y3`); 5 prov = 6 Provnode (\u0026#34;plus\u0026#34;, Provleaf \u0026#34;Q\u0026#34;, 7 Provnode (\u0026#34;times\u0026#34;, Provleaf \u0026#34;Q:cQ_Z_2\u0026#34;, Provleaf \u0026#34;P\u0026#34;)); 8 proc = 9 `_Step0 (cP_X_1,cQ_Z_2,c_Step0___Step0__y3) = 10 PiCutProc (A ++ B) c_Step0___Step0__z7 c_Step0___Step0__x3 11 oP_lB_A_Plus_B_rB_ 12 (PiWithProc (NEG A) (NEG B) c_Step0___Step0__x3 cQ_A_1 13 c_Step0___Step0__c3 14 c_Step0___Step0__uI3 15 c_Step0___Step0__vI3 16 (PiPlusLProc C (Z ** B) c_Step0___Step0__y3 oQ_C_ 17 c_Step0___Step0__uR3 18 c_Step0___Step0__vR3 19 (Q (cQ_A_1,cQ_Z_2,oQ_C_))) 20 (PiPlusRProc C (Z ** B) c_Step0___Step0__y3 c_Step0___Step0__d3 21 c_Step0___Step0__uE3 22 c_Step0___Step0__vE3 23 (PiTimesProc Z B c_Step0___Step0__d3 c_Step0___Step0__x4 24 c_Step0___Step0__y4 25 (PiIdProc Z cQ_Z_2 c_Step0___Step0__x4 c_Step0___Step0__m5) 26 (PiIdProc B c_Step0___Step0__c3 c_Step0___Step0__y4 27 c_Step0___Step0__m6)))) 28 (P (cP_X_1,oP_lB_A_Plus_B_rB_))`; 29 actions = 30 [{Action.act = \u0026#34;JOIN\u0026#34;; larg = \u0026#34;P\u0026#34;; lsel = \u0026#34;lr\u0026#34;; rarg = \u0026#34;Q\u0026#34;; rsel = \u0026#34;A\u0026#34;; 31 res = \u0026#34;_Step0\u0026#34;}]; 32 copier = false; intermediate = true}, 33 {Action.act = \u0026#34;JOIN\u0026#34;; larg = \u0026#34;P\u0026#34;; lsel = \u0026#34;lr\u0026#34;; rarg = \u0026#34;Q\u0026#34;; rsel = \u0026#34;A\u0026#34;; 34 res = \u0026#34;_Step0\u0026#34;}, 35 {Actionstate.label = \u0026#34;_Step0\u0026#34;; ctr = 0; 36 metas = 37 [`c_Step0___Step0__z7`; `c_Step0___Step0__y7`; `c_Step0___Step0__Q7`; 38 `c_Step0___Step0__m6`; `c_Step0___Step0__m5`; `c_Step0___Step0__x4`; 39 `c_Step0___Step0__y4`; `c_Step0___Step0__P4`; `c_Step0___Step0__Q4`; 40 `c_Step0___Step0__x3`; `c_Step0___Step0__c3`; `c_Step0___Step0__uI3`; 41 `c_Step0___Step0__vI3`; `c_Step0___Step0__uR3`; `c_Step0___Step0__vR3`; 42 `c_Step0___Step0__y3`; `c_Step0___Step0__d3`; `c_Step0___Step0__uE3`; 43 `c_Step0___Step0__vE3`; `c_Step0___Step0__Q3`; `cQ_A_1`; `cQ_Z_2`; 44 `oQ_C_`; `cP_X_1`; `oP_lB_A_Plus_B_rB_`]; 45 merged = []; 46 iprov = 47 [(`A ++ B`, Provnode (\u0026#34;plus\u0026#34;, Provleaf \u0026#34;cQ_A_1:1\u0026#34;, Provleaf \u0026#34;#\u0026#34;))]; 48 prov = 49 [(\u0026#34;Q\u0026#34;, Provleaf \u0026#34;Q\u0026#34;); 50 (\u0026#34;_Step0\u0026#34;, 51 Provnode (\u0026#34;plus\u0026#34;, Provleaf \u0026#34;Q\u0026#34;, 52 Provnode (\u0026#34;times\u0026#34;, Provleaf \u0026#34;Q:cQ_Z_2\u0026#34;, Provleaf \u0026#34;P\u0026#34;))); 53 (\u0026#34;P\u0026#34;, Provnode (\u0026#34;plus\u0026#34;, Provleaf \u0026#34;P\u0026#34;, Provleaf \u0026#34;P\u0026#34;))]}) compose1 The compose1 command composes two processes with an explicit composition action.\nIt takes 1 argument:\n Action.t: The composition action to perform.  This command is intended for advanced usage, for instance with a custom action, or some other action parameter not handled by the other commands.\nThe command returns a Compose response with the specification of the created intermediate composition, the composition action that was applied, and the resulting actionstate with additional metadata.\nNotes  If an intermediate composition with the same name as the action's result already exists, a warning will be shown and the old process will be replaced.  Example The following invocation of compose1 performs the parallel composition R of a process P with input X and output A ++ B and a process Q with inputs Y and Z and output C:\n1create \u0026#34;P\u0026#34; [`X`] `A ++ B` ;; 2create \u0026#34;Q\u0026#34; [`Y`; `Z`] `C` ;; 3compose1 {Action.act = \u0026#34;TENSOR\u0026#34;; larg = \u0026#34;P\u0026#34;; lsel = \u0026#34;\u0026#34;; rarg = \u0026#34;Q\u0026#34;; rsel = \u0026#34;\u0026#34;; res = \u0026#34;R\u0026#34;} ;; 1Console.Composer.Response.Compose 2 ({Console.Composer.Process.name = \u0026#34;R\u0026#34;; 3 inputs = [(`X`, `cP_X_1`); (`Y`, `cQ_Y_1`); (`Z`, `cQ_Z_2`)]; 4 output = (`(A ++ B) ** C`, `cR__R__z1`); 5 prov = 6 Provnode (\u0026#34;times\u0026#34;, Provnode (\u0026#34;plus\u0026#34;, Provleaf \u0026#34;P\u0026#34;, Provleaf \u0026#34;P\u0026#34;), 7 Provleaf \u0026#34;Q\u0026#34;); 8 proc = 9 `R (cP_X_1,cQ_Y_1,cQ_Z_2,cR__R__z1) = 10 PiTimesProc (A ++ B) C cR__R__z1 oP_lB_A_Plus_B_rB_ oQ_C_ 11 (P (cP_X_1,oP_lB_A_Plus_B_rB_)) 12 (Q (cQ_Y_1,cQ_Z_2,oQ_C_))`; 13 actions = 14 [{Action.act = \u0026#34;TENSOR\u0026#34;; larg = \u0026#34;P\u0026#34;; lsel = \u0026#34;\u0026#34;; rarg = \u0026#34;Q\u0026#34;; rsel = \u0026#34;\u0026#34;; 15 res = \u0026#34;R\u0026#34;}]; 16 copier = false; intermediate = true}, 17 {Action.act = \u0026#34;TENSOR\u0026#34;; larg = \u0026#34;P\u0026#34;; lsel = \u0026#34;\u0026#34;; rarg = \u0026#34;Q\u0026#34;; rsel = \u0026#34;\u0026#34;; 18 res = \u0026#34;R\u0026#34;}, 19 {Actionstate.label = \u0026#34;R\u0026#34;; ctr = 0; 20 metas = 21 [`cR__R__z1`; `cR__R__y1`; `cR__R__Q1`; `cQ_Y_1`; `cQ_Z_2`; `oQ_C_`; 22 `cP_X_1`; `oP_lB_A_Plus_B_rB_`]; 23 merged = []; iprov = []; 24 prov = 25 [(\u0026#34;R\u0026#34;, 26 Provnode (\u0026#34;times\u0026#34;, Provnode (\u0026#34;plus\u0026#34;, Provleaf \u0026#34;P\u0026#34;, Provleaf \u0026#34;P\u0026#34;), 27 Provleaf \u0026#34;Q\u0026#34;)); 28 (\u0026#34;P\u0026#34;, Provnode (\u0026#34;plus\u0026#34;, Provleaf \u0026#34;P\u0026#34;, Provleaf \u0026#34;P\u0026#34;)); 29 (\u0026#34;Q\u0026#34;, Provleaf \u0026#34;Q\u0026#34;)]}) ","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/console/commands/","title":"Commands"},{"body":"The second mode of the WorkflowFM Reasoner exposes a JSON API that can enable interaction with external and web based systems.\nThe JSON API mode can be loaded using the following command:\n1loads (!hol_dir ^ \u0026#34;/workflowfm/make.ml\u0026#34;);; The rest of this section describes the main types involved in the JSON schema, as well as the format for providing commands and the responses the reasoner can generate.\n","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/json/","title":"JSON API"},{"body":"Linear Propositions linprop\nDescription: Linear terms are either:\n atoms subterms connected by tensor or plus negations of terms  Structure:  type: string = \u0026quot;var\u0026quot; | \u0026quot;neg\u0026quot; | \u0026quot;times\u0026quot; | \u0026quot;plus\u0026quot; name: string = the name of the atom if type = \u0026quot;var\u0026quot;, otherwise ignored args: array of linprop = the list of arguments if type is neg, times or plus, otherwise ignored. Binary operators times and plus can have more than 2 arguments, in which case they are applied in a right associative way  Annotated terms linterm\nDescription: Annotated terms are linear propositional terms annotated with a channel.\nStructure:  cll: linprop channel: string  Composition actions action\nDescription: Composition actions describe a binary combination of 2 labelled processes.\nStructure:  act: string = the type of composition, currently \u0026quot;JOIN\u0026quot; | \u0026quot;TENSOR\u0026quot; | \u0026quot;WITH\u0026quot; for sequential, parallel, and conditional composition respectively larg: string = the name of the first (or \u0026quot;left\u0026quot;) component process lsel: string = a string describing some relevant part of the left process component. This is different depending on the action type. rarg: string = the name of the second (or \u0026quot;right\u0026quot;) component process rsel: string = a string describing some relevant part of the right process component. This is different depending on the action type. res: string = the desired label for the resulting composition  Provenance prov\nDescription: Provenance trees are used to determine the origin of each linear proposition in an input or output term.\nStructure:  type: string = \u0026quot;source\u0026quot; | \u0026quot;times\u0026quot; | \u0026quot;plus\u0026quot; name: string = the provenance label if type = \u0026quot;source\u0026quot;, otherwise ignored args: array of prov = the list of arguments if type is times or plus, otherwise ignored. Binary operators times and plus can have more than 2 arguments, in which case they are applied in a right associative way  Provenance entries prov_entry and iprov_entry\nDescription: Provenance info is kept in the actionstate. Provenance entries associate a provenance tree to the output (prov_entry) or input (iprov_entry) it corresponds to. Output provenance is associated with a process label whose output it describes. Input provenance is associated with an available input term.\nStructure: prov_entry:\n name: string = the name/label of the process whose output we are describing prov: prov = the corresponding provenance tree  iprov_entry:\n term: linprop = the (non-negated) linear term of the input we are describing prov: prov = the corresponding provenance tree  Actionstate actionstate\nDescription: The actionstate is used to convey state info to the prover and retrieve proof metadata afterwards.\nStructure:  label: string = a unique label identifying the composite process under contruction ctr: int = a non-negative counter used to keep variables fresh. Expected to be initialized to 0. buffered: array of linprop = the types of buffers that were constructed during proof. This used to be the way to determine buffered edges in the frontend, but is now obsolete thanks to the provenance trees. joined: array of linterm = the inputs that were used up/connected during a JOIN action. iprov: array of iprov_entry = input povenance entries prov: array of prov_entry = output provenance entries  Agent agent\nAn agent refers to a π-calculus definition corresponding to a process specification. Currently this is just a string, but we have plans to adopt a more structured representation in the near future.\nProcess process\nDescription: The complete specification of a process.\nStructure:  name: string = a name/label for the process inputs: array of linterm output: linterm prov: prov = the output provenance proc: agent = the pi-calculus specification actions: array of action = a list of composition actions that construct this process. Empty if the process is atomic. copier: bool = true if the prover determines this to be a copy node intermediate: bool = true if this is an intermediate composition step (as opposed to an atomic process or completed composition)  ","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/json/types/","title":"Main Types"},{"body":"JSON commands can be issued to the WorkflowFM Reasoner using the following function:\n1Json_composer_io.execute \u0026#34;JSON\u0026#34;;; Replace JSON with one of the commands described below, in JSON format.\nYou can also execute a JSON command stored in a file as follows:\n1Json_composer_io.execute_file \u0026#34;path/to/file.json\u0026#34;;;  All commands include a command field of type string which defines the type of the command.  Ping Description: Ping/keep-alive command. Gives a Pong response.\nStructure:  command: string = \u0026quot;ping\u0026quot; ping: float = a timestamp to measure ping  Create Description: A command to create a new atomic process.\nStructure:  command: string = \u0026quot;create\u0026quot; name: string = the name of the process to be created inputs: array of linprop = a list of inputs. Their channels will be created by the prover. output: linprop = the process output. The channcel will be created by the prover.  Binary compose (compose1) Description: Binary composition of 2 processes with a single action.\nAlthough a more general composition command is provided, when it comes to simple binary compositions this command executes faster.\nStructure:  command: string = \u0026quot;compose1\u0026quot; action: action = the composition action to be performed. The labels of the 2 arguments must match the labels of the processes provided in the next fields. lhs: process = the process corresponding to the first (left) argument of the action rhs: process = the process corresponding to the second (right) argument of the action  Compose Description: Construction of a complex composition with one or more actions. Although more general than the binary composition command compose1, it is slower.\nStructure:  command: string = \u0026quot;compose\u0026quot; name: string = the name of the final composition components: array of process = the list of all component processes that will be used actions: array of action = the ordered list of actions to be performed  Verify Description: A command used to reconstruct a process composition.\nThis is legacy command which has now devolved into the compose command. The only difference is that verify does not produce compose responses for intermediate steps. It will only generate one verify response for the final process.\nStructure:  command: string = \u0026quot;verify\u0026quot; name: string = the name of the final composition components: array of process = the list of all component processes that will be used actions: array of action = the ordered list of actions to be performed  Deploy Description: This is a family of commands that produce executable process deployments.\nThere are currently 3 types of possible deployments:\n PiViz: This produces a file for the PiVizTool and/or MWB. PiLib: This produces a deployment and code templates using the old PiLib library. PEW: This produces a deployment and code templates with the newer PEW library.  Structure: PiViz  command: string = \u0026quot;piviz\u0026quot; process: process = the process to be deployed components: array of process = the list of all dependencies/components required in the composition  PiLib  command: string = \u0026quot;pilib\u0026quot; process: process = the process to be deployed components: array of process = the list of all dependencies/components required in the composition separator: string = the client OS-specific file path separator path: string = the base path for the deployment pkg: string = the desired name for the Scala package that will contain the code project: string = an identifiable name for the deployment. This will be used to identify certain types and classes. main: bool = true if the generation of a template for a main class is required. java: bool = true if the generation of a java runner class is required. This can help integrate the Scala deployment with Java code.  PEW  command: string = \u0026quot;piviz\u0026quot; process: process = the process to be deployed components: array of process = the list of all dependencies/components required in the composition separator: string = the client OS-specific file path separator path: string = the base path for the deployment pkg: string = the desired name for the Scala package that will contain the code project: string = an identifiable name for the deployment. This will be used to identify certain types and classes. main: bool = true if the generation of a template for a main class is required. java: bool = true if the generation of a java runner class is required. This can help integrate the Scala deployment with Java code.  ","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/json/commands/","title":"Commands"},{"body":"JSON responses are provided in standard output, wrapped between a line containing the string JSON_START and a line containing the string JSON_END. HOL Light will also yield additional output outside those 2 lines.\nYou can therefore parse JSON output using a regular expression of the form \u0026quot;JSON_START(.*?)JSON_END\u0026quot;.\nAll responses include a response field of type string which defines the type of the response.  Pong Description: The response to the Ping command.\nStructure:  response: string = \u0026quot;Pong\u0026quot; ping: float = contains the original timestamp received by the prover in the Ping command.  Create Description: The response to the create command with a definition of a new atomic process.\nStructure:  response: string = \u0026quot;CreateProcess\u0026quot; process: process = the newly created process  Compose Description: The result of a single binary composition action. The compose command may produce multiple of these, one for each action.\nStructure:  response: string = \u0026quot;Compose\u0026quot; action: action = the composition action that was applied process: process = the resulting composite process state: actionstate = the updated action state with the associated metadata  Verify Description: The response of the verify command with a reconstructed composite process.\nStructure:  response: string = \u0026quot;Verify\u0026quot; process: process = the reconstructed composition  Deploy Description: This is the response to the deploy commands. It describes the files that are required for deployment.\nStructure: First we need the structure for a single deployment file. This is a file object containing the following fields:\n path: string = the full path of the file (including its name) in the deployment content: string = the content of the file overwrite: bool = the reasoner tags the files that are generated fully automatically so that they will be overwritten in consecutive deployments. Files that may be edited by the user (e.g. code templates) have this field marked as false to avoid overwritting user content.  Based on this, the deploy response is as follows:\n response: string = \u0026quot;Deploy\u0026quot; type: string = the type of deployment. Currently one of PiViz, PiLib or PEW. deployment: Array of file = a list of deployment files.  Failed Description: This response is generated whenever the prover fails to perform a command. Unless there is a bug or associated limitation in the prover, this indicates a user or input error.\nStructure:  response: string = \u0026quot;CommandFailed\u0026quot; content: string = a (sometimes useful) description of the error that occured  Exception Description: This response is generated whenever the prover fails due to an internal exception. This indicates an expected failure in the system.\nStructure:  response: string = \u0026quot;Exception\u0026quot; content: string = the contents of the thrown exception  ","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/json/responses/","title":"Responses"},{"body":"Welcome to the WorkflowFM Reasoner documentation. This is a HOL Light library that allows for rigorous, formally verified process specification and composition. Processes can be specified based on the types of their input and output resources, using Classical Linear Logic (CLL) sequents. Composition can then be achieved using forward chaining/inference of CLL rules.\nInference can be applied directly using the standard HOL Light interactive proof setting and the embed library. Alternatively, the WorkflowFM Reasoner also provides its own interface with intuitive commands that greatly facilitate process specification and composition.\nCLL proofs are annotated with π-calculus process terms based on the proofs-as-processes paradigm. These provide an executable translation of the logical composition. The resulting workflows are correct-by-construction with the following verified properties:\n Systematic resource accounting: The linearity of CLL guarantees that no resources appear out of nowhere or disappear into thin air. Deadlock and livelock freedom: The proofs-as-processes paradigm guarantees that the constructed workflows have no deadlocks or livelocks. Type checked composition: Even though the generated π-calculus term is untyped, the correctness of the types of all connected resources is ensured via the logical proof. Fully asynchronous and concurrent execution: The π-calculus naturally offers a workflow execution style where each component process can be executed fully asynchronously (see the PEW engine for more details) and concurrently, without introducing any conflicts, race conditions, or deadlocks.  The constructed workflows can be exported either for visualization using the PiVizTool or as Scala code for execution using the PEW engine.\nGet started ","link":"https://docs.workflowfm.com/workflowfm-reasoner/docs/","title":"Reference"},{"body":" \nA logic-based library for correct-by-construction process modelling and composition.  Read the DocsSource\nAbout This is a logic-based library for the interactive theorem prover HOL Light that allows for rigorous, formally verified process specification and composition. The resulting workflows are correct-by-construction with the following verified properties:\n Systematic resource accounting: No resources appear out of nowhere or disappear into thin air. Deadlock and livelock freedom: The constructed workflows can be executed without fear for deadlocks or livelocks. Type checked composition: The correctness of the types of all connected resources is ensured via the logical proof. Fully asynchronous and concurrent execution: During workflow execution, each component process can be executed fully asynchronously (see the PEW engine for more details) and concurrently, without introducing any conflicts, race conditions, or deadlocks.  The constructed workflows can be exported either for visualization using the PiVizTool or as Scala code for execution using the PEW engine.\nKey Features  Process specification using Classical Linear Logic (CLL). Process composition using formally verified forward inference. Interactive theorem proving in CLL. Intuitive high-level actions for sequential, conditional, and parallel composition. Proof translation to π-calculus. Modular encoding allows different CLL translations (e.g. to session types), automatically reconstructing the entire process reasoning framework. Tracking of provenance metadata during proof to guide visualization. Export π-calculus to PiVizTool format. Export Scala code to execute workflows using the PEW engine. Modular API allows extensions with new composition actions, export options and commands.  Modes The reasoner can run in 2 modes:\n Console: This mode is intended for standard use within HOL Light, i.e. at the OCaml toplevel. It provides a minimal console interface for process modelling and composition. JSON: This mode is intended for use within a server environment, to allow interaction with web applications (including UIs). It expects input and produces output encoded in JSON format.  \nAuthors Maintainer Petros Papapanagiotou -  -  - \nContributors A big thank you to the following contributors in order of appearance:\n Jacques Fleuriot -   Groups \u0026amp; Organizations   Artificial Intelligence Modelling Lab   Artificial Intelligence and its Applications Institute   School of Informatics, University of Edinburgh    \nReferences Please cite the following publication in reference to this project:\n P. Papapanagiotou, J. Fleuriot. WorkflowFM: A Logic-Based Framework for Formal Process Specification and Composition. CADE, 2017.  Sample of other relevant references:\n P. Papapanagiotou, J. Fleuriot. Formal Verification of Web Services Composition Using Linear Logic and the pi-calculus. ECOWS, 2011. P. Papapanagiotou. A formal verification approach to process modelling and composition. PhD Thesis, 2014. P. Papapanagiotou, J. Fleuriot. A Pragmatic, Scalable Approach to Correct-by-construction Process Composition Using Classical Linear Logic Inference. LOPSTR, 2019.  License Distributed under the Apache 2.0 license. See LICENSE for more information.\nCopyright © 2009-2021 The University of Edinburgh and contributors\n","link":"https://docs.workflowfm.com/workflowfm-reasoner/","title":"WorkflowFM Reasoner"}]