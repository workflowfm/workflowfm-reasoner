<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>WorkflowFM Reasoner</title><link>https://docs.workflowfm.com/workflowfm-reasoner/</link><description>Recent content on WorkflowFM Reasoner</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://docs.workflowfm.com/workflowfm-reasoner/index.xml" rel="self" type="application/rss+xml"/><item><title>Setup</title><link>https://docs.workflowfm.com/workflowfm-reasoner/docs/install/setup/</link><pubDate>Mon, 14 Jun 2021 23:25:24 +0100</pubDate><guid>https://docs.workflowfm.com/workflowfm-reasoner/docs/install/setup/</guid><description>Quick setup Clone the following repository: https://github.com/workflowfm/hol-light
1git clone https://github.com/workflowfm/hol-light.git Then make sure all the submodules are initialised and updated:
1git submodule update --init --recursive Manual setup Assuming an existing installation of HOL Light, you can setup the reasoner manually by installing the following libraries:
The Isabelle Light library. This also comes bundled with HOL Light by default. Additional HOL Light tools. This consists of useful snippets of code, libraries, and theorems.</description></item><item><title>Install HOL Light</title><link>https://docs.workflowfm.com/workflowfm-reasoner/docs/install/hol-light/</link><pubDate>Mon, 14 Jun 2021 23:25:26 +0100</pubDate><guid>https://docs.workflowfm.com/workflowfm-reasoner/docs/install/hol-light/</guid><description>You can install HOL Light by following its standard installation instructions.
We have included our own notes below in case they are helpful.
Specific tips for DICE users at the University of Edinburgh are included below. Install OCaml OCaml 4.07.0 minimum is required. The easiest way to install this is through opam.
On DICE, opam can be compiled from source and installed locally. It is better to use a locally installed OCaml than the centrally available one.</description></item><item><title>Loading the reasoner</title><link>https://docs.workflowfm.com/workflowfm-reasoner/docs/install/load/</link><pubDate>Mon, 14 Jun 2021 23:25:28 +0100</pubDate><guid>https://docs.workflowfm.com/workflowfm-reasoner/docs/install/load/</guid><description>Once you have HOL Light up and running, you can load the reasoner in console mode using the following command:
1loads (!hol_dir ^ &amp;#34;/workflowfm/make.console.ml&amp;#34;);; If you need to use the JSON mode, you can use this command instead:
1loads (!hol_dir ^ &amp;#34;/workflowfm/make.ml&amp;#34;);;</description></item><item><title>Resources</title><link>https://docs.workflowfm.com/workflowfm-reasoner/docs/elements/resources/</link><pubDate>Mon, 14 Jun 2021 23:25:43 +0100</pubDate><guid>https://docs.workflowfm.com/workflowfm-reasoner/docs/elements/resources/</guid><description>Processes are specified based on their input and output resources. Each resource is specified by its type and a π-calculus channel that receives or sends it.
Resource types Resource types are specified by a proposition in linear logic. In HOL Light these are propositions of type `:LinProp`.
Resource type names need to follow the same naming restrictions as HOL Light variables, i.e. they need to start with a letter and contain only letters and numbers.</description></item><item><title>Processes</title><link>https://docs.workflowfm.com/workflowfm-reasoner/docs/elements/processes/</link><pubDate>Mon, 14 Jun 2021 23:25:44 +0100</pubDate><guid>https://docs.workflowfm.com/workflowfm-reasoner/docs/elements/processes/</guid><description>Processes are defined based on their input and outputs resources, as well as some additional metadata.
The full process data structure is the following:
1module type Process_type = 2sig 3 type t = { 4 name : string; 5 inputs : (term * term) list; 6 output : term * term; 7 prov : provtree; 8 proc : term; 9 actions : Action.t list; 10 copier : bool; 11 intermediate : bool; 12 } 13(* .</description></item><item><title>Composition</title><link>https://docs.workflowfm.com/workflowfm-reasoner/docs/elements/composition/</link><pubDate>Mon, 14 Jun 2021 23:25:46 +0100</pubDate><guid>https://docs.workflowfm.com/workflowfm-reasoner/docs/elements/composition/</guid><description>Composition is achieved through binary actions that compose 2 processes together. Although there is some high level user control over the actions, the composition is automated and strictly follows the rules of linear logic.
The result is an intermediate composite process specified by its input and output resources and a correct-by-construction, executable π-calculus definition. These processes can then be further composed using subsequent actions.
Performing an action involved the production and maintenance of a temporary internal state called an actionstate.</description></item><item><title>Provenance</title><link>https://docs.workflowfm.com/workflowfm-reasoner/docs/elements/provenance/</link><pubDate>Mon, 14 Jun 2021 23:25:47 +0100</pubDate><guid>https://docs.workflowfm.com/workflowfm-reasoner/docs/elements/provenance/</guid><description>When composing processes, it is often necessary to keep track of which component processes own the inputs and outputs (or rather the different parts of the single output) of a composite process. We call this information provenance.
For example, provenance can provide essential metadata to be able to correctly visualize a composite process diagrammatically.
Example We begin with a motivating example to explain the purpose that provenance fulfils for the visualization of resource-based composition.</description></item><item><title>State</title><link>https://docs.workflowfm.com/workflowfm-reasoner/docs/console/state/</link><pubDate>Mon, 14 Jun 2021 23:26:04 +0100</pubDate><guid>https://docs.workflowfm.com/workflowfm-reasoner/docs/console/state/</guid><description>The console maintains an internal state of the introduced processes and compositions. This includes a list of atomic and stored processes and a separate list of intermediate processes. This allows the user to easily remove all intermediate processes when starting a new composition.
General The following commands are general purpose, spanning across the whole state:
Command Result get &amp;quot;P&amp;quot; Returns the process named &amp;quot;P&amp;quot;, whether it is atomic, intermediate or stored.</description></item><item><title>Commands</title><link>https://docs.workflowfm.com/workflowfm-reasoner/docs/console/commands/</link><pubDate>Mon, 14 Jun 2021 23:26:05 +0100</pubDate><guid>https://docs.workflowfm.com/workflowfm-reasoner/docs/console/commands/</guid><description>This section covers the main process specification and composition commands.
It is worth noting that the result of these commands is of type Composer.Response, which is defined as follows:
1module Response : 2 sig 3 type t = 4 | Ping of float 5 | Create of Process.t 6 | Compose of Process.t * Action.t * Actionstate.t 7 | Verify of Process.t 8 | Deploy of string * (string * string * bool) list 9 | Failed of string 10 | Exception of string 11 (*.</description></item><item><title>Main Types</title><link>https://docs.workflowfm.com/workflowfm-reasoner/docs/json/types/</link><pubDate>Mon, 14 Jun 2021 23:26:18 +0100</pubDate><guid>https://docs.workflowfm.com/workflowfm-reasoner/docs/json/types/</guid><description>Linear Propositions linprop
Description: Linear terms are either:
atoms subterms connected by tensor or plus negations of terms Structure: type: string = &amp;quot;var&amp;quot; | &amp;quot;neg&amp;quot; | &amp;quot;times&amp;quot; | &amp;quot;plus&amp;quot; name: string = the name of the atom if type = &amp;quot;var&amp;quot;, otherwise ignored args: array of linprop = the list of arguments if type is neg, times or plus, otherwise ignored. Binary operators times and plus can have more than 2 arguments, in which case they are applied in a right associative way Annotated terms linterm</description></item><item><title>Commands</title><link>https://docs.workflowfm.com/workflowfm-reasoner/docs/json/commands/</link><pubDate>Mon, 14 Jun 2021 23:26:20 +0100</pubDate><guid>https://docs.workflowfm.com/workflowfm-reasoner/docs/json/commands/</guid><description>JSON commands can be issued to the WorkflowFM Reasoner using the following function:
1Json_composer_io.execute &amp;#34;JSON&amp;#34;;; Replace JSON with one of the commands described below, in JSON format.
You can also execute a JSON command stored in a file as follows:
1Json_composer_io.execute_file &amp;#34;path/to/file.json&amp;#34;;; All commands include a command field of type string which defines the type of the command. Ping Description: Ping/keep-alive command. Gives a Pong response.
Structure: command: string = &amp;quot;ping&amp;quot; ping: float = a timestamp to measure ping Create Description: A command to create a new atomic process.</description></item><item><title>Responses</title><link>https://docs.workflowfm.com/workflowfm-reasoner/docs/json/responses/</link><pubDate>Mon, 14 Jun 2021 23:26:21 +0100</pubDate><guid>https://docs.workflowfm.com/workflowfm-reasoner/docs/json/responses/</guid><description>JSON responses are provided in standard output, wrapped between a line containing the string JSON_START and a line containing the string JSON_END. HOL Light will also yield additional output outside those 2 lines.
You can therefore parse JSON output using a regular expression of the form &amp;quot;JSON_START(.*?)JSON_END&amp;quot;.
All responses include a response field of type string which defines the type of the response. Pong Description: The response to the Ping command.</description></item><item><title>Search</title><link>https://docs.workflowfm.com/workflowfm-reasoner/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.workflowfm.com/workflowfm-reasoner/search/</guid><description/></item></channel></rss>