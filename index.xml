<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>WorkflowFM Reasoner</title><link>https://dev.workflowfm.com/workflowfm-reasoner/</link><description>Recent content on WorkflowFM Reasoner</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://dev.workflowfm.com/workflowfm-reasoner/index.xml" rel="self" type="application/rss+xml"/><item><title>Setup</title><link>https://dev.workflowfm.com/workflowfm-reasoner/docs/install/setup/</link><pubDate>Mon, 07 Jun 2021 14:08:32 +0100</pubDate><guid>https://dev.workflowfm.com/workflowfm-reasoner/docs/install/setup/</guid><description>Quick setup Clone the following repository: https://github.com/workflowfm/hol-light
1git clone https://github.com/workflowfm/hol-light.git Then make sure all the submodules are initialised and updated:
1git submodule update --init --recursive Manual setup Assuming an existing installation of HOL Light, you can setup the reasoner manually by installing the following libraries:
The Isabelle Light library. This also comes bundled with HOL Light by default. Additional HOL Light tools. This consists of useful snippets of code, libraries, and theorems.</description></item><item><title>Install HOL Light</title><link>https://dev.workflowfm.com/workflowfm-reasoner/docs/install/hol-light/</link><pubDate>Mon, 07 Jun 2021 14:08:33 +0100</pubDate><guid>https://dev.workflowfm.com/workflowfm-reasoner/docs/install/hol-light/</guid><description>You can install HOL Light by following its standard installation instructions.
We have included our own notes below in case they are helpful.
Specific tips for DICE users at the University of Edinburgh are included below.
Install OCaml OCaml 4.07.0 minimum is required. The easiest way to install this is through opam.
On DICE, opam can be compiled from source and installed locally. It is better to use a locally installed OCaml than the centrally available one.</description></item><item><title>Loading the reasoner</title><link>https://dev.workflowfm.com/workflowfm-reasoner/docs/install/load/</link><pubDate>Mon, 07 Jun 2021 14:08:33 +0100</pubDate><guid>https://dev.workflowfm.com/workflowfm-reasoner/docs/install/load/</guid><description>Once you have HOL Light up and running, you can load the reasoner in console mode using the following command:
1loads (!hol_dir ^ &amp;#34;/workflowfm/make.console.ml&amp;#34;);; If you need to use the JSON mode, you can use this command instead:
1loads (!hol_dir ^ &amp;#34;/workflowfm/make.ml&amp;#34;);;</description></item><item><title>Main Types</title><link>https://dev.workflowfm.com/workflowfm-reasoner/docs/json/types/</link><pubDate>Mon, 07 Jun 2021 15:16:56 +0100</pubDate><guid>https://dev.workflowfm.com/workflowfm-reasoner/docs/json/types/</guid><description>Linear Propositions linprop
Description:
Linear terms are either:
atoms subterms connected by tensor or plus negations of terms Structure:
type: string = &amp;quot;var&amp;quot; | &amp;quot;neg&amp;quot; | &amp;quot;times&amp;quot; | &amp;quot;plus&amp;quot; name: string = the name of the atom if type = &amp;quot;var&amp;quot;, otherwise ignored args: array of linprop = the list of arguments if type is neg, times or plus, otherwise ignored. Binary operators times and plus can have more than 2 arguments, in which case they are applied in a right associative way Annotated terms linterm</description></item><item><title>Commands</title><link>https://dev.workflowfm.com/workflowfm-reasoner/docs/json/commands/</link><pubDate>Mon, 07 Jun 2021 15:16:56 +0100</pubDate><guid>https://dev.workflowfm.com/workflowfm-reasoner/docs/json/commands/</guid><description>JSON commands can be issued to the WorkflowFM Reasoner using the following function:
1Json_composer_io.execute &amp;#34;JSON&amp;#34;;; Replace JSON with one of the commands described below, in JSON format.
You can also execute a JSON command stored in a file as follows:
1Json_composer_io.execute_file &amp;#34;path/to/file.json&amp;#34;;;
All commands include a command field of type string which defines the type of the command.
Ping Description:
Ping/keep-alive command. Gives a Pong response.
Structure:
command: string = &amp;quot;ping&amp;quot; ping: float = a timestamp to measure ping Create Description:</description></item><item><title>Responses</title><link>https://dev.workflowfm.com/workflowfm-reasoner/docs/json/responses/</link><pubDate>Mon, 07 Jun 2021 15:16:57 +0100</pubDate><guid>https://dev.workflowfm.com/workflowfm-reasoner/docs/json/responses/</guid><description>JSON responses are provided in standard output, wrapped between a line containing the string JSON_START and a line containing the string JSON_END. HOL Light will also yield additional output outside those 2 lines.
You can therefore parse JSON output using a regular expression of the form &amp;quot;JSON_START(.*?)JSON_END&amp;quot;.
All responses include a response field of type string which defines the type of the response.
Pong Description:
The response to the Ping command.</description></item><item><title>Example</title><link>https://dev.workflowfm.com/workflowfm-reasoner/docs/provenance/example/</link><pubDate>Mon, 07 Jun 2021 15:49:41 +0100</pubDate><guid>https://dev.workflowfm.com/workflowfm-reasoner/docs/provenance/example/</guid><description>We begin with a motivating example to explain the purpose that provenance fulfils for the visualization of resource-based composition.
Specification Assume the following process specifications:
P1: ⊢ NEG X, A ⊗ B P2: ⊢ NEG B, C ⊕ D Q1: ⊢ NEG A, E Q2: ⊢ NEG E, NEG (C ⊕ D), Y We then perform JOIN operations for each pair, obtaining the following intermediate compositions:
P: ⊢ NEG X, A ⊗ (C ⊕ D) Q: ⊢ NEG A, NEG (C ⊕ D), Y Finally, we JOIN the 2 results to obtain the final composition:</description></item><item><title>Output Provenance</title><link>https://dev.workflowfm.com/workflowfm-reasoner/docs/provenance/output/</link><pubDate>Mon, 07 Jun 2021 15:49:41 +0100</pubDate><guid>https://dev.workflowfm.com/workflowfm-reasoner/docs/provenance/output/</guid><description>Each process may only have a single, possibly composite output. When composing processes, the output of the composition often consists of parts of the outputs of its components.
In our example above, P has output A ⊗ (C ⊕ D) consisting of A coming from P1 and C ⊕ D coming from P2. This is exactly what the provenance tree represents.
The output provenance tree of each process is stored in its structure and used during composition.</description></item><item><title>Provenance Trees</title><link>https://dev.workflowfm.com/workflowfm-reasoner/docs/provenance/trees/</link><pubDate>Mon, 07 Jun 2021 15:49:41 +0100</pubDate><guid>https://dev.workflowfm.com/workflowfm-reasoner/docs/provenance/trees/</guid><description>We want to be able to track provenance of specific CLL resources. This means subterms of the same term can have different provenance. For this reason, we track provenance using a binary tree structure that matches the syntax tree of the term. The leaves of the tree contain provenance values instead of CLL propositions.
Here is the syntax and provenance trees for the output of P from the example:
1⊗ ⊗ 2|\ |\ 3| \ | \ 4A ⊕ P1 ⊕ 5 |\ |\ 6 | \ | \ 7 C D P2 P2 If all the propositions in a (sub)tree have the same provenance, we can collapse the provenance (sub)tree to a single node:</description></item><item><title>Input Provenance</title><link>https://dev.workflowfm.com/workflowfm-reasoner/docs/provenance/input/</link><pubDate>Mon, 07 Jun 2021 15:49:42 +0100</pubDate><guid>https://dev.workflowfm.com/workflowfm-reasoner/docs/provenance/input/</guid><description>Each process can have multiple inputs, each with its own unique channel. This means we can generally track the owner of an input through the channel.
In our example above, NEG (C ⊕ D) of Q2 will have a unique channel name, let's assume cQ. When composing Q1 with Q2, this input is not affected. This means if we try to connect something to it, we already know cQ belongs to Q2 so we can track its provenance and connect the graph appropriately.</description></item><item><title>Future Work</title><link>https://dev.workflowfm.com/workflowfm-reasoner/docs/provenance/future/</link><pubDate>Mon, 07 Jun 2021 15:49:42 +0100</pubDate><guid>https://dev.workflowfm.com/workflowfm-reasoner/docs/provenance/future/</guid><description>Further clarifying and simplifying the provenance information is an obvious want for the future.
A few particularities exist because of the violation of channel uniqueness, so solving this problem in a more general way will help simplify provenance too.
Depending on further developments and needs of the frontend graph engine, we may extend provenance labels. The fact that the leaves can have any string as a label makes this structure very flexible and expandable.</description></item><item><title>Search</title><link>https://dev.workflowfm.com/workflowfm-reasoner/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dev.workflowfm.com/workflowfm-reasoner/search/</guid><description/></item></channel></rss>