<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Provenance on WorkflowFM Reasoner</title><link>https://dev.workflowfm.com/workflowfm-reasoner/docs/provenance/</link><description>Recent content in Provenance on WorkflowFM Reasoner</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Mon, 07 Jun 2021 15:49:40 +0100</lastBuildDate><atom:link href="https://dev.workflowfm.com/workflowfm-reasoner/docs/provenance/index.xml" rel="self" type="application/rss+xml"/><item><title>Example</title><link>https://dev.workflowfm.com/workflowfm-reasoner/docs/provenance/example/</link><pubDate>Mon, 07 Jun 2021 15:49:41 +0100</pubDate><guid>https://dev.workflowfm.com/workflowfm-reasoner/docs/provenance/example/</guid><description>We begin with a motivating example to explain the purpose that provenance fulfils for the visualization of resource-based composition.
Specification Assume the following process specifications:
P1: ⊢ NEG X, A ⊗ B P2: ⊢ NEG B, C ⊕ D Q1: ⊢ NEG A, E Q2: ⊢ NEG E, NEG (C ⊕ D), Y We then perform JOIN operations for each pair, obtaining the following intermediate compositions:
P: ⊢ NEG X, A ⊗ (C ⊕ D) Q: ⊢ NEG A, NEG (C ⊕ D), Y Finally, we JOIN the 2 results to obtain the final composition:</description></item><item><title>Output Provenance</title><link>https://dev.workflowfm.com/workflowfm-reasoner/docs/provenance/output/</link><pubDate>Mon, 07 Jun 2021 15:49:41 +0100</pubDate><guid>https://dev.workflowfm.com/workflowfm-reasoner/docs/provenance/output/</guid><description>Each process may only have a single, possibly composite output. When composing processes, the output of the composition often consists of parts of the outputs of its components.
In our example above, P has output A ⊗ (C ⊕ D) consisting of A coming from P1 and C ⊕ D coming from P2. This is exactly what the provenance tree represents.
The output provenance tree of each process is stored in its structure and used during composition.</description></item><item><title>Provenance Trees</title><link>https://dev.workflowfm.com/workflowfm-reasoner/docs/provenance/trees/</link><pubDate>Mon, 07 Jun 2021 15:49:41 +0100</pubDate><guid>https://dev.workflowfm.com/workflowfm-reasoner/docs/provenance/trees/</guid><description>We want to be able to track provenance of specific CLL resources. This means subterms of the same term can have different provenance. For this reason, we track provenance using a binary tree structure that matches the syntax tree of the term. The leaves of the tree contain provenance values instead of CLL propositions.
Here is the syntax and provenance trees for the output of P from the example:
1⊗ ⊗ 2|\ |\ 3| \ | \ 4A ⊕ P1 ⊕ 5 |\ |\ 6 | \ | \ 7 C D P2 P2 If all the propositions in a (sub)tree have the same provenance, we can collapse the provenance (sub)tree to a single node:</description></item><item><title>Input Provenance</title><link>https://dev.workflowfm.com/workflowfm-reasoner/docs/provenance/input/</link><pubDate>Mon, 07 Jun 2021 15:49:42 +0100</pubDate><guid>https://dev.workflowfm.com/workflowfm-reasoner/docs/provenance/input/</guid><description>Each process can have multiple inputs, each with its own unique channel. This means we can generally track the owner of an input through the channel.
In our example above, NEG (C ⊕ D) of Q2 will have a unique channel name, let's assume cQ. When composing Q1 with Q2, this input is not affected. This means if we try to connect something to it, we already know cQ belongs to Q2 so we can track its provenance and connect the graph appropriately.</description></item><item><title>Future Work</title><link>https://dev.workflowfm.com/workflowfm-reasoner/docs/provenance/future/</link><pubDate>Mon, 07 Jun 2021 15:49:42 +0100</pubDate><guid>https://dev.workflowfm.com/workflowfm-reasoner/docs/provenance/future/</guid><description>Further clarifying and simplifying the provenance information is an obvious want for the future.
A few particularities exist because of the violation of channel uniqueness, so solving this problem in a more general way will help simplify provenance too.
Depending on further developments and needs of the frontend graph engine, we may extend provenance labels. The fact that the leaves can have any string as a label makes this structure very flexible and expandable.</description></item></channel></rss>